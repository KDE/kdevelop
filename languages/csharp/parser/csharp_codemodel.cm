-- This file is part of KDevelop.
-- Copyright (c) 2006 Jakob Petsovits <jpetso@gmx.at>
--
-- This grammar is free software; you can redistribute it and/or
-- modify it under the terms of the GNU Library General Public
-- License as published by the Free Software Foundation; either
-- version 2 of the License, or (at your option) any later version.
--
-- This grammar is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Library General Public License
-- along with this library; see the file COPYING.LIB.  If not, write to
-- the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-- Boston, MA 02110-1301, USA.


------------------------------------------------------------
-- Code model for C#
------------------------------------------------------------

[:
#include "csharp_ast.h"

#include "codedisplay.h"

#include <QtCore/QString>
#include <QtCore/QStringList>
:]


CodeModel
{
  root = globalNamespace: GlobalNamespaceDeclaration;

  constructor
  [:
    _M_globalNamespace = create<ITEM(GlobalNamespaceDeclaration)>();
  :]

  destructor
  [:
    // FIXME jpetso: don't we need "delete _M_globalNamespace;" here?
  :]

  -- TODO: provide findItem() method
}

Code
{
  name:     QString;
  scope:    QStringList;
  fileName: QString;

  public declaration
  [:
    QStringList qualifiedName() const;

    // TODO: These methods should be cached upon initialization
    QString display() const;
    QIcon decoration() const;
    QString toolTip() const;
    QString whatsThis() const;
  :]

  implementation
  [:
    QStringList CLASS::qualifiedName() const
    {
        QStringList q = scope();

        if (!name().isEmpty())
            q += name();

        return q;
    }

    // TODO: These methods should be cached upon initialization
    QString CLASS::display() const
    {
      return CodeDisplay::display( const_cast<const CLASS*>( this ) );
    }
    QIcon CLASS::decoration() const
    {
      return CodeDisplay::decoration( const_cast<const CLASS*>( this ) );
    }
    QString CLASS::toolTip() const
    {
      return CodeDisplay::toolTip( const_cast<const CLASS*>( this ) );
    }
    QString CLASS::whatsThis() const
    {
      return CodeDisplay::whatsThis( const_cast<const CLASS*>( this ) );
    }
  :]
}

Scope: Code
{
  public declaration
  [:
    QStringList context()
    {
        if (name().isNull())
            return scope();
        else
            return scope() << name();
    }
  :]
}

NamespaceDeclaration: Scope
{
  #namespace:       NamespaceDeclaration { childitem, hashed(name) };
  #externAlias:     ExternAliasDirective { hashed(name) };
  #usingAlias:      UsingAliasDirective  { hashed(name) };
  #usingNamespace:  UsingNamespaceDirective;

  #class:           ClassDeclaration     { childitem, hashed(name) };
  #struct:          StructDeclaration    { childitem, hashed(name) };
  #interface:       InterfaceDeclaration { childitem, hashed(name) };
  #enum:            EnumDeclaration      { childitem, hashed(name) };
  #delegate:        DelegateDeclaration  { childitem, hashed(name) };
}

GlobalNamespaceDeclaration: NamespaceDeclaration
{
  constructor       [: setName( QString::null ); :]
}

ExternAliasDirective: Code
{
}

UsingAliasDirective: Code
{
  namespaceOrType:  Type;
}

UsingNamespaceDirective: Code
{
  constructor       [: setName( QString::null ); :]
  namespaceUsed:    QStringList; -- namespaces may not have type arguments
}

TypeDeclaration: Scope
{
  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  isNew:            bool { init[: false :] };
}

ClassLikeDeclaration: TypeDeclaration  -- a class, struct or interface type
{
  baseType:         Type;

  #event:           EventDeclaration     { childitem, hashed(name) };
  #indexer:         IndexerDeclaration   { childitem };
  #property:        PropertyDeclaration  { childitem, hashed(name) };
  #method:          MethodDeclaration    { childitem, multihashed(name) };
    -- { childitem, multihashed(name),
    --   unique [: !existingItem->isSimilar( model_static_cast<ITEM(Code)>(item) ) :]
    -- };
  #typeParameter:   TypeParameter;
  #typeParameterConstraint: TypeParameterConstraint;

  isUnsafe:         bool { init[: false :] };

  -- only inside class or struct declarations, not interfaces:
  #class:           ClassDeclaration     { childitem, hashed(name) };
  #struct:          StructDeclaration    { childitem, hashed(name) };
  #interface:       InterfaceDeclaration { childitem, hashed(name) };
  #enum:            EnumDeclaration      { childitem, hashed(name) };
  #delegate:        DelegateDeclaration  { childitem, hashed(name) };
  #variable:        VariableDeclaration  { childitem, hashed(name) };

  public declaration
  [:
    ITEM(MethodDeclaration) declaredMethod(ITEM(MethodDeclaration) item);
  :]

  implementation
  [:
    ITEM(MethodDeclaration) CLASS::declaredMethod(ITEM(MethodDeclaration) item)
    {
        LIST(MethodDeclaration) methodList = findMethods(item->name());

        foreach (ITEM(MethodDeclaration) method, methodList)
        {
            if (method->isSimilar(model_static_cast<ITEM(Code)>(item),false))
                return method;
        }

      return ITEM(MethodDeclaration)();
    }
 :]
}

ClassDeclaration: ClassLikeDeclaration
{
  isSealed:         bool { init[: false :] };
  isAbstract:       bool { init[: false :] };
  isStatic:         bool { init[: false :] };
}

StructDeclaration: ClassLikeDeclaration
{
}

InterfaceDeclaration: ClassLikeDeclaration
{
}

DelegateDeclaration: TypeDeclaration
{
  returnType:       Type;
  #parameter:       Parameter;
  #typeParameter:   TypeParameter;
  #typeParameterConstraint: TypeParameterConstraint;

  isUnsafe:         bool { init[: false :] };
}

EnumDeclaration: TypeDeclaration
{
  #enumValue:       EnumValue { childitem };
  baseIntegralType: Type;
}

EnumValue: Code
{
  value:            QString;
}

EventDeclaration: Scope
{
  type:             Type;
  fromInterface:    Type;
  addAccessor:      EventAccessorDeclaration;
  removeAccessor:   EventAccessorDeclaration;

  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  isNew:            bool { init[: false :] };
  isStatic:         bool { init[: false :] };
  isVirtual:        bool { init[: false :] };
  isSealed:         bool { init[: false :] };
  isOverride:       bool { init[: false :] };
  isAbstract:       bool { init[: false :] };
  isExtern:         bool { init[: false :] };
  isUnsafe:         bool { init[: false :] };
}

EventAccessorDeclaration: Code
{
}

IndexerDeclaration: Scope
{
  constructor       [: setName( QString::null ); :] -- indexers don't have names

  type:             Type;
  fromInterface:    Type;
  #parameter:       Parameter;
  #accessor:        AccessorDeclaration { childitem };

  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  isNew:            bool { init[: false :] };
  isVirtual:        bool { init[: false :] };
  isSealed:         bool { init[: false :] };
  isOverride:       bool { init[: false :] };
  isAbstract:       bool { init[: false :] };
  isExtern:         bool { init[: false :] };
  isUnsafe:         bool { init[: false :] };
}

PropertyDeclaration: Scope
{
  type:             Type;
  fromInterface:    Type;
  #accessor:        AccessorDeclaration { childitem };

  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  isNew:            bool { init[: false :] };
  isStatic:         bool { init[: false :] };
  isVirtual:        bool { init[: false :] };
  isSealed:         bool { init[: false :] };
  isOverride:       bool { init[: false :] };
  isAbstract:       bool { init[: false :] };
  isExtern:         bool { init[: false :] };
  isUnsafe:         bool { init[: false :] };
}

AccessorDeclaration: Code
{
  type:             accessor_declarations::accessor_type_enum;
  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  hasAccessPolicy:  bool { init[: false :] };
}

MethodDeclaration: Scope
{
  returnType:       Type;
  fromInterface:    Type;
  #typeParameter:   TypeParameter;
  #typeParameterConstraint: TypeParameterConstraint;
  #parameter:       Parameter;

  isInterfaceMethodDeclaration: bool { init[: false :] };

  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  isNew:            bool { init[: false :] };
  isStatic:         bool { init[: false :] };
  isVirtual:        bool { init[: false :] };
  isSealed:         bool { init[: false :] };
  isOverride:       bool { init[: false :] };
  isAbstract:       bool { init[: false :] };
  isExtern:         bool { init[: false :] };
  isUnsafe:         bool { init[: false :] };

  #localVariable:   VariableDeclaration;
}

ConstructorDeclaration: MethodDeclaration
{
}

FinalizerDeclaration: MethodDeclaration
{
}

VariableDeclaration: Code
{
  type:             Type;

  accessPolicy:     access_policy::access_policy_enum
                         { init[: access_policy::access_private :] };
  isConstant:       bool { init[: false :] };
  isNew:            bool { init[: false :] };
  isStatic:         bool { init[: false :] };
  isReadonly:       bool { init[: false :] };
  isVolatile:       bool { init[: false :] };
  isUnsafe:         bool { init[: false :] };
}

TypePart: Code
{
  -- unfortunately, we can't bind the type to its declaration currently,
  -- because there's no way to have another pass after parsing all documents
  -- (which would be needed to know all the existing type declarations)
  -- typeDeclaration:  TypeDeclaration;

  #typeArgument:    Type;

  public declaration
  [:
    bool operator==( const _TypePartModelItem &other );
    bool operator!=( const _TypePartModelItem &other ) { return !(*this == other); }

    QString toString() const;
  :]

  implementation
  [:
    QString CLASS::toString() const
    {
        //QString typeString = typeDeclaration()->name();
        QString typeString = name();

        if ( !typeArguments().empty() )
        {
            typeString += "<";
            bool initial = true;

            foreach ( ITEM(Type) argument, typeArguments() )
            {
                if ( !initial )
                    typeString += ", ";

                typeString += argument->toString();
                initial = false;
            }

            typeString += ">";
        }

        return typeString;
    }

    bool CLASS::operator==(const CLASS &other)
    {
        //if ( typeDeclaration() != other.typeDeclaration() ) // not yet possible
        if ( name() != other.name() )
            return false;

        if ( typeArguments().count() != other.typeArguments().count() )
            return false;

        LIST(Type)::const_iterator argument = typeArguments().begin();
        LIST(Type)::const_iterator otherArgument = other.typeArguments().begin();

        for ( ; argument == typeArguments().end(); argument++, otherArgument++ )
        {
            if ( *argument != *otherArgument )
                return false;
        }

        return true;
    }
  :]
}

Type: Code
{
  -- types consist of multiple type parts, but don't have a single name
  constructor
  [:
    setName( QString::null );
    setQualifiedAliasLabel( QString::null );
  :]

  qualifiedAliasLabel: QString;
  #typePart:        TypePart;

  public declaration
  [:
    bool operator==( const _TypeModelItem &other );
    bool operator!=( const _TypeModelItem &other ) { return !(*this == other); }

    QString toString() const;
  :]

  implementation
  [:
    QString CLASS::toString() const
    {
        QString typeString;
        bool initial = true;

        if ( !qualifiedAliasLabel().isNull() )
            typeString = qualifiedAliasLabel() + "::";

        foreach ( ITEM(TypePart) part, typeParts() )
        {
            if ( !initial )
                typeString += ".";

            typeString += part->toString();
            initial = false;
        }

        return typeString;
    }

    bool CLASS::operator==(const CLASS &other)
    {
        if ( typeParts().count() != other.typeParts().count() )
            return false;

        LIST(TypePart)::const_iterator part = typeParts().begin();
        LIST(TypePart)::const_iterator otherPart = other.typeParts().begin();

        for ( ; part == typeParts().end(); part++, otherPart++ )
        {
            if ( *part != *otherPart )
                return false;
        }

        return true;
    }
  :]
}

Parameter: Code
{
  type:             Type;
  isArray:          bool { init[: false :] };
  parameterType:    parameter::parameter_type_enum
                         { init[: parameter::value_parameter :] };

  public declaration
  [:
    QString toString() const
    {
        Q_ASSERT( type() );
        return type()->toString() + " " + name();
    }
  :]
}

TypeParameter: Code
{
}

TypeParameterConstraint: Code
{
}

PrimaryOrSecondaryConstraint: TypeParameterConstraint
{
  typeOrParameterName: Type;
  constraint_type:  primary_or_secondary_constraint::primary_or_secondary_constraint_enum
                      { init[: primary_or_secondary_constraint::type_type :] };
}

ConstructorConstraint: TypeParameterConstraint
{
}
