<HTML>
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>set_union</Title>
<!-- Generated by htmldoc -->
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="CorpID.gif" 
     ALT="SGI" HEIGHT="43" WIDTH="151"> 
<!--end header-->
<BR Clear>
<H1>set_union</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "algorithms.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "function.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
<TD Align=right VAlign=top><b>Component type</b>: function</TD>
</TR>
</Table>

<h3>Prototype</h3>
<tt>Set_union</tt> is an overloaded name; there are actually two <tt>set_union</tt>
functions.
<pre>
template &lt;class <A href="InputIterator.html">InputIterator</A>1, class <A href="InputIterator.html">InputIterator</A>2, class <A href="OutputIterator.html">OutputIterator</A>&gt;
OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);

template &lt;class <A href="InputIterator.html">InputIterator</A>1, class <A href="InputIterator.html">InputIterator</A>2, class <A href="OutputIterator.html">OutputIterator</A>,
          class <A href="StrictWeakOrdering.html">StrictWeakOrdering</A>&gt;
OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, 
                         StrictWeakOrdering comp);
</pre>                   
<h3>Description</h3>
<tt>Set_union</tt> constructs a sorted range that is the union of the 
sorted ranges <tt>[first1, last1)</tt> and <tt>[first2, last2)</tt>.  
The return value is the end of the output range.
<P>
In the simplest case, <tt>set_union</tt> performs the &quot;union&quot; operation from
set theory: the output range contains a copy of every element that is
contained in <tt>[first1, last1)</tt>, <tt>[first2, last2)</tt>, or both.  The
general case is more complicated, because the input ranges may contain
duplicate elements.  The generalization is that if a value appears <tt>m</tt>
times in <tt>[first1, last1)</tt> and <tt>n</tt> times in <tt>[first2, last2)</tt> (where
<tt>m</tt> or <tt>n</tt> may be zero), then it appears <tt>max(m,n)</tt> times in the
output range. <A href="#1">[1]</A>  <tt>Set_union</tt> is stable, meaning both that the
relative order of elements within each input range is preserved, and
that if an element is present in both input ranges it is copied from
the first range rather than the second.
<P>
The two versions of <tt>set_union</tt> differ in how they define whether one
element is less than another.  The first version compares
objects using <tt>operator&lt;</tt>, and the second compares objects using
a <A href="functors.html">function object</A> <tt>comp</tt>.
<h3>Definition</h3>
Defined in the standard header <A href="algorithm">algorithm</A>, and in the nonstandard
backward-compatibility header <A href="algo.h">algo.h</A>.
<h3>Requirements on types</h3>
For the first version:
<UL>
<LI>
<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>OutputIterator</tt> is a model of <A href="OutputIterator.html">Output Iterator</A>.
<LI>
<tt>InputIterator1</tt> and <tt>InputIterator2</tt> have the same value type.
<LI>
<tt>InputIterator</tt>'s value type is a model of <A href="LessThanComparable.html">LessThan Comparable</A>.
<LI>
The ordering on objects of <tt>InputIterator1</tt>'s value type is a <i>strict
   weak ordering</i>, as defined in the <A href="LessThanComparable.html">LessThan Comparable</A> requirements.
<LI>
<tt>InputIterator</tt>'s value type is convertible to a type in
   <tt>OutputIterator</tt>'s set of value types.
</UL>
For the second version:
<UL>
<LI>
<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
<LI>
<tt>OutputIterator</tt> is a model of <A href="OutputIterator.html">Output Iterator</A>.
<LI>
<tt>StrictWeakOrdering</tt> is a model of <A href="StrictWeakOrdering.html">Strict Weak Ordering</A>.
<LI>
<tt>InputIterator1</tt> and <tt>InputIterator2</tt> have the same value type.
<LI>
<tt>InputIterator1</tt>'s value type is convertible to <tt>StrictWeakOrdering</tt>'s
   argument type.
<LI>
<tt>InputIterator</tt>'s value type is convertible to a type in
   <tt>OutputIterator</tt>'s set of value types.
</UL>
<h3>Preconditions</h3>
For the first version:
<UL>
<LI>
<tt>[first1, last1)</tt> is a valid range.
<LI>
<tt>[first2, last2)</tt> is a valid range.
<LI>
<tt>[first1, last1)</tt> is ordered in ascending order according to
   <tt>operator&lt;</tt>.  That is, for every pair of iterators <tt>i</tt> and <tt>j</tt>
   in <tt>[first1, last1)</tt> such that <tt>i</tt> precedes <tt>j</tt>, 
   <tt>*j &lt; *i</tt> is <tt>false</tt>.
<LI>
<tt>[first2, last2)</tt> is ordered in ascending order according to
   <tt>operator&lt;</tt>.  That is, for every pair of iterators <tt>i</tt> and <tt>j</tt>
   in <tt>[first2, last2)</tt> such that <tt>i</tt> precedes <tt>j</tt>, 
   <tt>*j &lt; *i</tt> is <tt>false</tt>.
<LI>
There is enough space to hold all of the elements being copied.
   More formally, the requirement is that 
   <tt>[result, result + n)</tt> is a valid range, where <tt>n</tt> is the number
   of elements in the union of the two input ranges.
<LI>
<tt>[first1, last1)</tt> and <tt>[result, result + n)</tt> do not overlap.
<LI>
<tt>[first2, last2)</tt> and <tt>[result, result + n)</tt> do not overlap.
</UL>
For the second version:
<UL>
<LI>
<tt>[first1, last1)</tt> is a valid range.
<LI>
<tt>[first2, last2)</tt> is a valid range.
<LI>
<tt>[first1, last1)</tt> is ordered in ascending order according to
   <tt>comp</tt>.  That is, for every pair of iterators <tt>i</tt> and <tt>j</tt>
   in <tt>[first1, last1)</tt> such that <tt>i</tt> precedes <tt>j</tt>, 
   <tt>comp(*j, *i)</tt> is <tt>false</tt>.
<LI>
<tt>[first2, last2)</tt> is ordered in ascending order according to
   <tt>comp</tt>.  That is, for every pair of iterators <tt>i</tt> and <tt>j</tt>
   in <tt>[first2, last2)</tt> such that <tt>i</tt> precedes <tt>j</tt>, 
   <tt>comp(*j, *i)</tt> is <tt>false</tt>.
<LI>
There is enough space to hold all of the elements being copied.
   More formally, the requirement is that 
   <tt>[result, result + n)</tt> is a valid range, where <tt>n</tt> is the number
   of elements in the union of the two input ranges.
<LI>
<tt>[first1, last1)</tt> and <tt>[result, result + n)</tt> do not overlap.
<LI>
<tt>[first2, last2)</tt> and <tt>[result, result + n)</tt> do not overlap.
</UL>
<h3>Complexity</h3>
Linear.  Zero comparisons if either <tt>[first1, last1)</tt> or <tt>[first2, last2)</tt>
is empty, otherwise at most <tt>2 * ((last1 - first1) + (last2 - first2))
- 1</tt> comparisons.
<h3>Example</h3>
<pre>
inline bool lt_nocase(char c1, char c2) { return tolower(c1) &lt; tolower(c2); }

int main()
{
  int A1[] = {1, 3, 5, 7, 9, 11};
  int A2[] = {1, 1, 2, 3, 5, 8, 13};  
  char A3[] = {'a', 'b', 'B', 'B', 'f', 'H'};
  char A4[] = {'A', 'B', 'b', 'C', 'D', 'F', 'F', 'h', 'h'};

  const int N1 = sizeof(A1) / sizeof(int);
  const int N2 = sizeof(A2) / sizeof(int); 
  const int N3 = sizeof(A3);
  const int N4 = sizeof(A4);

  cout &lt;&lt; &quot;Union of A1 and A2: &quot;;
  set_union(A1, A1 + N1, A2, A2 + N2,
            ostream_iterator&lt;int&gt;(cout, &quot; &quot;));
  cout &lt;&lt; endl 
       &lt;&lt; &quot;Union of A3 and A4: &quot;;
  set_union(A3, A3 + N3, A4, A4 + N4, 
            ostream_iterator&lt;char&gt;(cout, &quot; &quot;),
            lt_nocase);
  cout &lt;&lt; endl;
}
</pre>        
<P>
The output is
<pre>
Union of A1 and A2: 1 1 2 3 5 7 8 9 11 13 
Union of A3 and A4: a b B B C D f F H h 
</pre>
<h3>Notes</h3>
<P><A name="1">[1]</A>
Even this is not a completely precise description, because 
the ordering by which the input ranges are sorted
is permitted to be a strict weak ordering that is not a total ordering:
there might be values
<tt>x</tt> and <tt>y</tt> that are equivalent (that is, neither <tt>x &lt; y</tt> nor <tt>y &lt; x</tt>)
but not equal.  See the <A href="LessThanComparable.html">LessThan Comparable</A> requirements
for a more complete discussion.  If the range <tt>[first1, last1)</tt> contains <tt>m</tt>
elements that are equivalent to each other and the range <tt>[first2,
last2)</tt> contains <tt>n</tt> elements from that equivalence class (where
either <tt>m</tt> or <tt>n</tt> may be zero), then the output range contains
<tt>max(m, n)</tt> elements from that equivalence class.  Specifically, <tt>m</tt>
of these elements will be copied from <tt>[first1, last1)</tt> and <tt>max(n-m,
0)</tt> of them will be copied from <tt>[first2, last2)</tt>.  Note that this
precision is only important if elements can be
equivalent but not equal.  If you're using a total ordering
(if you're using <tt>strcmp</tt>, for example, or if you're using
ordinary arithmetic comparison on integers), then you can ignore this
technical distinction: for a total ordering, equality and equivalence
are the same.
<h3>See also</h3>
<tt><A href="includes.html">includes</A></tt>, <tt><A href="set_intersection.html">set_intersection</A></tt>, <tt><A href="set_difference.html">set_difference</A></tt>, 
<tt><A href="set_symmetric_difference.html">set_symmetric_difference</A></tt>, <tt><A href="sort.html">sort</A></tt>, <tt><A href="merge.html">merge</A></tt>

<!--start footer--> 
<HR SIZE="6">
<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
        ALT="[Silicon Surf]"></A>
<A HREF="index.html"><IMG SRC="stl_home.gif" 
        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
<BR>
<FONT SIZE="-2">
<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
</FONT>
<P>
</BODY>
</HTML> 
