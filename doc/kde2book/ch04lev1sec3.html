<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Using Child Widgets</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="Creating Custom KDE Widgets"
HREF="ch04.html"/><LINK
REL="PREVIOUS"
TITLE="Painting Widgets"
HREF="ch04lev1sec2.html"/><LINK
REL="NEXT"
TITLE="Handling User Input"
HREF="ch04lev1sec4.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch04lev1sec2.html"
>Prev</A
> <A
HREF="ch04lev1sec4.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch04lev1sec3"
>4.3. Using Child Widgets</A
></H1
><P
>You should use the KDE and Qt widgets provided in the respective libraries as children of your custom widgets wherever they would be useful and appropriate. By doing so, you save on development time and reduce the overall memory footprint of your application. If the user is running your application under KDE (or is running another KDE-based application), your application will be sharing the KDE and Qt libraries with the programs already using them. The code you write from scratch is not shared and thus increases the overall memory use of your application + KDE.</P
><P
>You already saw in <A
HREF="ch02.html"
>Chapter 2</A
> how child widgets are used by <TT
CLASS="literal"
>KTMainWindow</TT
>. The menubar, toolbar, status line, and content area are all children of <TT
CLASS="literal"
>KTMainWindow</TT
>.</P
><P
>Now you will design a simple widget, called <TT
CLASS="literal"
>KChildren</TT
>, that creates children and connects them to each other using the signal/slot mechanism to deliver a functioning, custom widget. All this widget's functionality, therefore, comes from its child widgets! The widget is shown in <A
HREF="ch04lev1sec3.html#ch04fig02"
>Figure 4.2</A
>, and its code is given in Listings 4.5&#8211;4.7.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch04fig02"
></A
><P
><B
>Figure 4.2. The <TT
CLASS="literal"
>KChildren</TT
> widget shows how to use child widgets to easily create custom widgets.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/04fig02.gif"
></IMG
></P
></DIV
><HR/></DIV
><DIV
CLASS="example"
><HR/><A
NAME="ch04list05"
></A
><P
><B
>Example 4.5. kchildren.h Contains the Class Declaration for <TT
CLASS="literal"
>KChildren</TT
>, a Custom Widget</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;#ifndef __KCHILDREN_H__
   3&nbsp;#define __KCHILDREN_H__
   4&nbsp;
   5&nbsp;/**
   6&nbsp; * KChildren
   7&nbsp; * Create and connect some child widgets.
   8&nbsp; **/
   9&nbsp;
  10&nbsp;#include &lt;qwidget.h&gt;
  11&nbsp;
  12&nbsp;class KChildren : public QWidget
  13&nbsp;{
  14&nbsp; public:
  15&nbsp;  KChildren (QWidget *parent, const char *name=0);
  16&nbsp;};
  17&nbsp;
  18&nbsp;#endif</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>This class declaration (<A
HREF="ch04lev1sec3.html#ch04list05"
>Listing 4.5</A
>) is perhaps the simplest you could imagine for KDE widget, yet the widget is still functional.</P
><P
>The next listing, <A
HREF="ch04lev1sec3.html#ch04list06"
>Listing 4.6</A
>, shows the class definition that, in this case, consists mainly of the definition of the class constructor.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch04list06"
></A
><P
><B
>Example 4.6. kchildren.cpp is the Class Definition for <TT
CLASS="literal"
>KChildren</TT
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;1: #include &lt;qlcdnumber.h&gt;
   3&nbsp;2: #include &lt;qslider.h&gt;
   4&nbsp;3:
   5&nbsp;4: #include "kchildren.h"
   6&nbsp;5:
   7&nbsp;6: KChildren::KChildren (QWidget *parent, const char *name) :
   8&nbsp;7:   QWidget (parent, name)
   9&nbsp;8: {
  10&nbsp;9:
  11&nbsp;10:   QLCDNumber *qlcdnumber = new QLCDNumber (2, this);
  12&nbsp;11:   qlcdnumber-&gt;display (0);
  13&nbsp;12:   qlcdnumber-&gt;setGeometry (10, 10, 100, 150);
  14&nbsp;13:
  15&nbsp;14:   QSlider *qslider = new QSlider (Qt::Horizontal, this);
  16&nbsp;15:   qslider-&gt;setGeometry (10, 165, 100, 10);
  17&nbsp;16:
  18&nbsp;17:   connect ( qslider, SIGNAL (valueChanged (int)),
  19&nbsp;18:         qlcdnumber, SLOT (display (int)) );
  20&nbsp;19:
  21&nbsp;20: }</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>This widget creates an LCD number and slider as child widgets. The child widgets are managed by the Qt classes <TT
CLASS="literal"
>QLCDNumber</TT
> and <TT
CLASS="literal"
>QSlider</TT
>, respectively. In <A
HREF="ch04lev1sec3.html#ch04list06"
>Listing 4.6</A
> on line 17, the call to <TT
CLASS="literal"
>connect()</TT
> connects the <TT
CLASS="literal"
>QSlider::valueChanged(int)</TT
> signal to the <TT
CLASS="literal"
>QLCDNumber:: display(int)</TT
> slot so that whenever the user moves the slider, the LCD number is updated. The actual number displayed is determined by <TT
CLASS="literal"
>QSlider</TT
> and ranges from 0 at full left to 99 at full right.</P
><P
>In this particular simple widget all the functionality is provided by the KDE/Qt child widgets. In general, you'll have to do a little more work than simply instantiating widgets and connecting them, but the KDE/Qt widgets let you think more about the unique functionality of your application and less about the details of UI components.</P
><P
><A
HREF="ch04lev1sec3.html#ch04list07"
>Listing 4.7</A
> shows a <TT
CLASS="literal"
>main()</TT
> function that can be used to test the function that can be used to test the <TT
CLASS="literal"
>KChildren</TT
> widget. Following convention, this program would be compiled to an executable called <TT
CLASS="literal"
>kchildrentest</TT
>.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch04list07"
></A
><P
><B
>Example 4.7. main.cpp is a <TT
CLASS="literal"
>main()</TT
> Function Suitable for Testing the <TT
CLASS="literal"
>KChildren</TT
> Widget</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;#include &lt;kapp.h&gt;
   3&nbsp;#include "kchildren.h"
   4&nbsp;int
   5&nbsp;main (int argc, char *argv[])
   6&nbsp;{
   7&nbsp;  KApplication kapplication (argc, argv, "kchildrentest");
   8&nbsp;  KChildren *kchildren = new KChildren (0);
   9&nbsp;  kapplication.setMainWidget (kchildren);
  10&nbsp;  kchildren-&gt;show();
  11&nbsp;  return kapplication.exec();
  12&nbsp;}</PRE
></TD
></TR
></TABLE
><HR/></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec11"
>4.3.1. Geometry Management</A
></H2
><P
>In this widget you do need to do a little more than create and connect the widgets, as I alluded to previously. You need to position them (relative to the main widget, <TT
CLASS="literal"
>KChildren</TT
>) and set their size. This is called <I
CLASS="emphasis"
>geometry management</I
>.  In <TT
CLASS="literal"
>KChildren</TT
> the geometry management was performed by placing the widgets at fixed, hard coded positions and giving them fixed sizes. For example, line 12 of <A
HREF="ch04lev1sec3.html#ch04list06"
>Listing 4.6</A
>,</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;qlcdnumber-&gt;setGeometry (10, 10, 100, 150);</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>places the LCD number widget's upper-left corner at 10 pixels to the right and 10 pixels down from the <TT
CLASS="literal"
>KChildren</TT
> widget's upper-left corner. The LCD number widget has a width of 100 pixels and a height of 150 pixels.</P
><P
>This is poor geometry management. Why? Try resizing the window. Notice that the child widgets are unaffected&#8212;even if you resize the window so small that the child widgets cannot be accessed (see <A
HREF="ch04lev1sec3.html#ch04fig03"
>Figure 4.3</A
>). Proper geometry management should take into account the size of the parent widget and the size requirements of the child widgets. (A widget may, for example, need to be of some minimum size before it can be drawn in a reasonably useful or recognizable way.)</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch04fig03"
></A
><P
><B
>Figure 4.3. The <TT
CLASS="literal"
>KChildren</TT
> widget does not adapt to different-sized windows because it uses poor geometry management.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/04fig03.gif"
></IMG
></P
></DIV
><HR/></DIV
><P
>Qt provides two geometry managers that can take care of this task for you in most cases. They are <TT
CLASS="literal"
>QBoxLayout</TT
> and <TT
CLASS="literal"
>QGridLayout</TT
>. The former looks at your widgets as a horizontal or vertical string of widgets, and the latter places your widgets on a grid. <TT
CLASS="literal"
>QGridLayout</TT
> is the more flexible of the two, and I will show you an example using it.</P
><DIV
CLASS="note"
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="note.png"
HSPACE="5"
ALT="Note"/></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Use a geometry manager class to organize your widgets instead of hard coding pixel values.</P
></TD
></TR
></TABLE
></DIV
><P
>The widget <TT
CLASS="literal"
>KTicTacToe</TT
> is presented in Listings 4.8&#8211;4.10 It creates a tic-tac-toe game board by arranging nine <TT
CLASS="literal"
>KXOSquare</TT
> widgets in a 3×3 grid. See <A
HREF="ch04lev1sec3.html#ch04fig04"
>Figure 4.4</A
> for a screen shot of the widget.</P
><P
>The first listing, <A
HREF="ch04lev1sec3.html#ch04list08"
>Listing 4.8</A
>, shows the class declaration. Most of the work is done in the constructor, but you declare one slot, <TT
CLASS="literal"
>processClicks()</TT
>, which will interpret the user's mouse clicks.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch04fig04"
></A
><P
><B
>Figure 4.4. The <TT
CLASS="literal"
>KTicTacToe</TT
> widget uses the KXOSquare widget nine times to create a game board.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/04fig04.gif"
></IMG
></P
></DIV
><HR/></DIV
><DIV
CLASS="example"
><HR/><A
NAME="ch04list08"
></A
><P
><B
>Example 4.8. ktictactoe.h is the Class Declaration for the Widget <TT
CLASS="literal"
>KTicTacToe</TT
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;1: #ifndef __KTICTACTOE_H__
   3&nbsp;2: #define __KTICTACTOE_H__
   4&nbsp;3:
   5&nbsp;4: #include &lt;qarray.h&gt;
   6&nbsp;5: #include &lt;qwidget.h&gt;
   7&nbsp;6:
   8&nbsp;7: #include "kxosquare.h"
   9&nbsp;8:
  10&nbsp;9: /**
  11&nbsp;10:  * KTicTacToe
  12&nbsp;11:  * Draw and manage a Tic-Tac-Toe board using KXOSquare.
  13&nbsp;12:  **/
  14&nbsp;13: class KTicTacToe : public QWidget
  15&nbsp;14:{
  16&nbsp;15:  Q_OBJECT
  17&nbsp;16:
  18&nbsp;17:  public:
  19&nbsp;18:   /**
  20&nbsp;19:    * Create an empty game board.
  21&nbsp;20:    **/
  22&nbsp;21:   KTicTacToe (QWidget *parent, const char *name=0);
  23&nbsp;22:
  24&nbsp;23:
  25&nbsp;24:  protected slots:
  26&nbsp;25:    /**
  27&nbsp;26:     * Process user input.
  28&nbsp;27:     **/
  29&nbsp;28:    void processClicks (KXOSquare *, KXOSquare::State);
  30&nbsp;29:
  31&nbsp;30: };
  32&nbsp;31:
  33&nbsp;32: #endif</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>At the top of the grid is a <TT
CLASS="literal"
>QLabel</TT
> that displays the title <SPAN
CLASS="QUOTE"
>"Tic-Tac-Toe."</SPAN
> The grid that you create with <TT
CLASS="literal"
>QGridLayout</TT
> has 4 rows and 3 columns. Three rows are for the game board, and 1 extra row at the top is for the title. The title (the <TT
CLASS="literal"
>QLabel</TT
>) spans all 3 columns.</P
><P
>This work is done in the constructor, given in <A
HREF="ch04lev1sec3.html#ch04list09"
>Listing 4.9</A
>.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch04list09"
></A
><P
><B
>Example 4.9. ktictactoe.cpp is the Class Definition for <TT
CLASS="literal"
>KTicTacToe</TT
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;1: #include &lt;qlayout.h&gt;
   3&nbsp;2: #include &lt;qlabel.h&gt;
   4&nbsp;3:
   5&nbsp;4: #include "ktictactoe.moc"
   6&nbsp;5:
   7&nbsp;6: KTicTacToe::KTicTacToe (QWidget *parent, const char *name) :
   8&nbsp;7:   QWidget (parent, name)
   9&nbsp;8: {
  10&nbsp;9:   int row, col;
  11&nbsp;10:
  12&nbsp;11:   QGridLayout *layout = new QGridLayout (this, 4, 3);
  13&nbsp;12:
  14&nbsp;13:   const int rowlabel0 = 0, rowlabel1 = 0, collabel0 = 0, collabel1 = 2,
  15&nbsp;14:     rowsquares0 = 1, rowsquares1 = 4, colsquares0 = 0, colsquares1 = 3;
  16&nbsp;15:
  17&nbsp;16:   for (row=rowsquares0; row&lt;rowsquares1; row++)
  18&nbsp;17:     for (col=colsquares0; col&lt;colsquares1; col++)
  19&nbsp;18:       {
  20&nbsp;19:     KXOSquare *kxosquare = new KXOSquare (this);
  21&nbsp;20:     layout-&gt;addWidget (kxosquare, row, col);
  22&nbsp;21:     connect ( kxosquare,
  23&nbsp;22:           SIGNAL (changeRequest (KXOSquare *, KXOSquare::State)),
  24&nbsp;23:           SLOT (processClicks (KXOSquare *, KXOSquare::State)) );
  25&nbsp;24:       }
  26&nbsp;25:
  27&nbsp;26:   QLabel *label = new QLabel ("Tic-Tac-Toe", this);
  28&nbsp;27:   label-&gt;setAlignment (Qt::AlignCenter);
  29&nbsp;28:   label-&gt;setMinimumSize (label-&gt;sizeHint());
  30&nbsp;29:   layout-&gt;addMultiCellWidget (label,
  31&nbsp;30:                   rowlabel0, rowlabel1,
  32&nbsp;31:                   collabel0, collabel1);
  33&nbsp;32: }
  34&nbsp;33:
  35&nbsp;34:
  36&nbsp;35: void
  37&nbsp;36: KTicTacToe::processClicks (KXOSquare *square, KXOSquare::State state)
  38&nbsp;37: {
  39&nbsp;38:   //In this simple example, just pass along the click to the appropriate
  40&nbsp;39:   // square.
  41&nbsp;40   square-&gt;newState (state);
  42&nbsp;41: }</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The layout manager, of type <TT
CLASS="literal"
>QLayout</TT
>, is not a widget itself. On line 19, each child widget is created with <TT
CLASS="literal"
>KTicTacToe</TT
> as its parent.</P
><P
>A widget typically is added to the layout with <TT
CLASS="literal"
>QGridLayout::addWidget()</TT
>. For example, you add a <TT
CLASS="literal"
>KXOSquare</TT
> to the layout with</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;layout-&gt;addWidget (kxosquare, row, col);</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>in line 20 of <A
HREF="ch04lev1sec3.html#ch04list09"
>Listing 4.9</A
>.</P
><P
>You may break the strict grid structure of your widget by using <TT
CLASS="literal"
>QGridLayout:: addMultiCellWidget()</TT
>, as you did with <TT
CLASS="literal"
>QLabel</TT
> (lines 29-31):</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp; layout-&gt;addMultiCellWidget (label, rowlabel1, rowlabel2,
   3&nbsp;                             collabel1, collabel2);</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>This call adds <TT
CLASS="literal"
>QLabel</TT
> to the grid so that it spans column <TT
CLASS="literal"
>collabel1</TT
> to column <TT
CLASS="literal"
>collabel2</TT
>, or column 0 to column 2. Widgets can also call multiple rows. If <TT
CLASS="literal"
>rowlabel1</TT
> and <TT
CLASS="literal"
>rowlabel2</TT
> had different values, this call would make the <TT
CLASS="literal"
>QLabel</TT
> span row <TT
CLASS="literal"
>rowlabel1</TT
> to row <TT
CLASS="literal"
>rowlabel2</TT
>.</P
><P
>Now try resizing the window. The title text moves itself so that it is always centered, as requested on line 27 of <A
HREF="ch04lev1sec3.html#ch04list09"
>Listing 4.9</A
>.</P
><P
>The squares resize themselves to fit their parent widget, which, in turn, fills the window (see <A
HREF="ch04lev1sec3.html#ch04fig05"
>Figure 4.5</A
>). If you shrink the window very small, the squares nearly disappear, but the text remains totally visible (see <A
HREF="ch04lev1sec3.html#ch04fig06"
>Figure 4.6</A
>). This is because you set the minimum size of the <TT
CLASS="literal"
>QLabel</TT
> in line 28 of <A
HREF="ch04lev1sec3.html#ch04list09"
>Listing 4.9</A
> with</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;label-&gt;setMinimumSize (label-&gt;sizeHint());</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The <TT
CLASS="literal"
>QSize</TT
> class returned by <TT
CLASS="literal"
>label-&gt;sizeHint()</TT
> contains the size of the rectangle needed to comfortably contain the text. You didn't set any minimum size for the squares, so they are content simply to disappear as the window is made ever smaller.</P
><P
>You have used constants (for example, <TT
CLASS="literal"
>rowlabel1</TT
>, <TT
CLASS="literal"
>rowsquare1</TT
>) to describe the layout of the widgets on the grid instead of hard coding the values in the calls to <TT
CLASS="literal"
>addWidget()</TT
> and <TT
CLASS="literal"
>addMultiCellWidget()</TT
>. This keeps the specification of the layout of the entire grid in one location, lines 13 and 14 of <A
HREF="ch04lev1sec3.html#ch04list09"
>Listing 4.9</A
>, making future changes to it easier.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch04fig05"
></A
><P
><B
>Figure 4.5. The <TT
CLASS="literal"
>KTicTacToe</TT
> widget adapts to different-sized windows because it uses Qt's geometry management.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/04fig05.gif"
></IMG
></P
></DIV
><HR/></DIV
><DIV
CLASS="figure"
><HR/><A
NAME="ch04fig06"
></A
><P
><B
>Figure 4.6. The geometry manager was asked not to let the text label shrink too much. No such request was made for the game board, so it nearly disappears when you shrink the window too much.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/04fig06.gif"
></IMG
></P
></DIV
><HR/></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec11"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec11"
TITLE="Geometry Management"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec12"
>4.3.2. Playing the Game</A
></H2
><P
>This is quite a simple version of Tic-Tac-Toe. The <TT
CLASS="literal"
>KTicTacToe</TT
> widget doesn't enforce the rules and doesn't declare a winner! The slot <TT
CLASS="literal"
>KTicTacToe::processClicks()</TT
> is the place for this type of logic. The <TT
CLASS="literal"
>KXOSquare::changeRequest()</TT
> signal thus serves as a hook into the <TT
CLASS="literal"
>KXOSquare</TT
> widget, allowing you to intercept the simple <SPAN
CLASS="QUOTE"
>"click ==&gt; draw X or O"</SPAN
> logic and apply arbitrary logic to the widget's functioning. This is one way to make a widget more general and thus useful to more developers. To simplify the interface, you might add a (<TT
CLASS="literal"
>bool</TT
>) flag to the constructor's argument list, which, when <TT
CLASS="literal"
>true</TT
>, causes the constructor to connect the <TT
CLASS="literal"
>changeRequest()</TT
> signal to the <TT
CLASS="literal"
>newState()</TT
> slot. (Note: In this particular case, the arguments of the signal and slot don't match, so some intermediate slot, which called <TT
CLASS="literal"
>newState()</TT
> in <TT
CLASS="literal"
>KXOSquare,</TT
> is necessary.) If the flag had a default value of <TT
CLASS="literal"
>true</TT
>, the simplest usage of <TT
CLASS="literal"
>KXOSquare</TT
> gives the simplest behavior. More sophisticated behavior could still be achieved by sending <TT
CLASS="literal"
>false</TT
> for the flag's value and managing the signal as you did in <TT
CLASS="literal"
>KTicTacToe</TT
>.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec12"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec12"
TITLE="Playing the Game"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev1sec3"/></TD
></TR
><ANNOTATION
NAME="ch04lev1sec3"
TITLE="Using Child Widgets"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch04lev1sec2.html"
>Prev</A
> <A
HREF="ch04lev1sec4.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>