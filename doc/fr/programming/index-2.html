<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Le Manuel de Programmation de KDevelop: Les Bibliothèques de KDE et Qt </TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-3.html">Page suivante</A>
 <A HREF="index-1.html">Page précédente</A>
 <A HREF="index.html#toc2">Table des matières</A>
</P>
<H3><A NAME="s2">2. Les Bibliothèques de KDE et Qt </A></H3>

<P> 
La société norvégienne Troll Tech (
<A HREF="http://www.troll.no">http://www.troll.no</A>) fournit une boîte 
à outils graphique (NdT&nbsp;: GUI toolkit)  nommée Qt. Ici, graphique doit 
être pris au sens  d'"<B>I</B>nterface <B>U</B>tilisateur <B>G</B>raphique" (NdT&nbsp;: GUI 
signifie littéralement Graphical User Interface). Les applications basées sur Qt 
sont donc représentées par des boutons, des fenêtres, etc, permettant ainsi à l'utilisateur 
de visualiser les fonctions fournies par l'application. Une telle boîte à outils est 
nécessaire pour développer des applications graphiques qui s'exécutent sur l'interface 
X-Window des Systèmes Unix car X ne contient pas en lui-même d'interface utilisateur 
prédéfinie. Bien que d'autres boîtes à outils soient aussi disponibles pour 
créer des Interfaces Utilisateur, Qt offre des avantages techniques qui rendent 
la conception d'applications vraiment simple. En plus, Qt est aussi disponible
pour les systèmes Microsoft Windows, ce qui permet aux développeurs de fournir leurs 
applications pour les deux plates-formes. 
<P>
<P>L'équipe KDE (
<A HREF="http://www.kde.org">http://www.kde.org</A>) dont le but est de rendre l'utilisation 
des Systèmes Unix plus conviviale a décidé d'utiliser la boîte à outils Qt pour 
le développement d'un gestionnaire de fenêtres basé sur X-Window, et la réalisation 
d'un grand nombre d'outils inclus dans les paquetages de KDE. Les composants principaux 
de l'Environnement de Bureau KDE sont le gestionnaire de fenêtres <EM>kwm</EM>, le 
gestionnaire de fichiers <EM>kfm</EM>  et le tableau de bord <EM>kpanel</EM> ainsi que 
d'autres outils et applications de premier plan. Après la sortie de KDE, beaucoup 
de développeurs se sont intéressés à ce nouvel environnement et ce qu'il avait à 
leur offrir. Les bibliothèques de KDE fournissent les classes et les méthodes 
essentielles pour donner à vos applications une apparence similaire et homogène. 
Ainsi, l'utilisateur a l'énorme avantage de ne pas avoir besoin de s'accoutumer au 
comportement spécifique de chaque application ou à la façon de gérer les boîtes de 
dialogue ou les boutons. En plus, les programmes KDE s'intègrent eux-mêmes dans le 
bureau, sont capables d'interagir avec le gestionnaire de fichiers par 
glisser-déposer, autorisent la gestion de session et bien plus si toutes les 
fonctionnalités offertes par les bibliothèques de KDE sont utilisées. 
<P>La boîte à outils Qt et les bibliothèques de KDE sont toutes 
implantées dans le langage de programmation C++ ; aussi, les applications qui 
les utilisent sont généralement écrites en C++. Dans le chapitre suivant, nous 
survolerons les bibliothèques pour voir ce qui est déjà disponible et comment 
les applications KDE et Qt sont créées, en général. 
<P>
<P>
<H3><A NAME="ss2.1">2.1 La boîte à outils graphique Qt </A>
</H3>

<P> 
Comme mentionné précédemment, la bibliothèque Qt est une boîte à outils 
qui fournit des éléments graphiques qui sont utilisés pour créer des applications 
graphiques (NdT : GUI applications) et sont nécessaires pour programmer X-Window. 
De plus, cette boîte à outils offre : 
<P>
<UL>
<LI>un ensemble complet de classes et de méthodes prêtes à être utilisées 
même pour des fonctions non graphiques</LI>
<LI>une bonne solution pour les interactions avec l'utilisateur par 
l'intermédiaire des méthodes virtuelles et du mécanisme signal/slot</LI>
<LI>un ensemble d'éléments graphiques prédéfinis appelés widgets qui peuvent
facilement être utilisés pour créer les entités visibles</LI>
<LI>des boîtes de dialogue complètement pré-définies supplémentaires qui sont souvent
utilisées dans les applications (ouverture/enregistrement de fichiers,
progression d'opération...).  </LI>
</UL>
    
<P>Il apparaît donc essentiel de connaître les classes de Qt, même si vous 
voulez seulement programmer
des applications KDE. Pour avoir un aperçu de la façon dont les applications
graphiques sont compilées et construites, nous allons d'abord jeter un oeil à
un exemple de programme basé uniquement sur Qt ; ensuite, nous en ferons
un programme KDE.   
<P>
<H4>La première Application Qt </H4>

<P>  Comme d'habitude, les programmes écrits en C++ doivent contenir une fonction
<CODE>main()</CODE> qui est le point de départ de l'exécution de l'application. Comme
nous voulons qu'ils soient affichés
graphiquement dans des fenêtres et qu'ils permettent d'interagir avec
l'utilisateur, nous devons d'abord savoir comment ils peuvent s'afficher
eux-mêmes à l'utilisateur. À titre d'exemple, nous allons regarder le premier
tutoriel inclus dans la Documentation de Référence en ligne de Qt, 
expliquer les étapes de base de l'exécution et voir pourquoi et comment la
fenêtre de l'application apparaît :    
<BLOCKQUOTE><CODE>
<HR>
<PRE>
 
#include &lt;qapplication.h> 
#include &lt;qpushbutton.h> 
 
int main( int argc, char **argv ) 
{ 
QApplication a( argc, argv ); 
 
QPushButton hello( "Hello world!" ); 
hello.resize( 100, 30 ); 
 
a.setMainWidget( &amp;hello ); 
hello.show(); 
return a.exec(); 
} 
</PRE>
<HR>
</CODE></BLOCKQUOTE>
 
<P>Globalement, l'application dessine une fenêtre contenant un bouton dont le 
texte est "Hello world". Comme pour toute application basée sur Qt, 
vous devez d'abord créer une instance de la classe <CODE>QApplication</CODE>, 
ici représentée par <CODE>a</CODE>. 
<P>Ensuite, le programme crée une instance de la classe <CODE>QPushButton</CODE> appelée 
<CODE>hello</CODE>, ce sera le bouton. Le constructeur de <CODE>hello</CODE> prend en paramètre 
une chaîne de caractères qui est le contenu de la partie visible du widget,
c'est-à-dire le texte du bouton. 
<P>Ensuite, la méthode <CODE>resize()</CODE> est appelée pour le bouton <CODE>hello</CODE>. Cela 
remplace la taille par défaut qu'un widget (ici, c'est un QPushButton) a lorsqu'il 
est créé par une longueur de 100 pixels et une hauteur de 30 pixels. Enfin, la 
méthode <CODE>setMainWidget()</CODE> est appelée pour <CODE>a</CODE> et la méthode <CODE>show()</CODE> 
pour <CODE>hello</CODE>. La <CODE>QApplication</CODE> est enfin exécutée par le <CODE>a.exec()</CODE>, 
entre dans la boucle principale d'événements et attend jusqu'à devoir retourner 
une valeur entière au Système d'Exploitation sous-jacent pour lui signaler que 
l'application s'est terminée. 
<P>
<H4>Le Manuel de Référence de Qt </H4>

<P> 
Maintenant, regardons rapidement le manuel de référence de la 
bibliothèque Qt. Pour cela, lançons KDevelop et choisissons 
"Bibliothèque Qt" dans le menu "Aide" de la barre de menus. Le navigateur 
de documentation s'ouvre et affiche la page d'accueil de la référence de Qt. 
Ce sera votre source d'information privilégiée sur Qt, ses classes et les
fonctions disponibles. D'ailleurs, le programme ci-dessus est le premier qui 
est inclus dans la section des tutoriels. Pour accéder aux classes qui nous 
intéressent (<CODE>QApplication</CODE> et <CODE>QPushButton</CODE>), sélectionnez 
"Alphabetical Class List" et cherchez les noms correspondants. Cliquez sur le 
lien pour consulter la documentation de la classe. 
<P>Pour <CODE>QApplication</CODE>, vous verrez le constructeur et toutes les autres 
méthodes que fournit cette classe. Si vous suivez le lien, vous obtiendrez plus 
d'informations sur l'utilisation et la signification des méthodes, ce qui est 
très utile quand vous ne devinez pas l'utilisation appropriée ou que vous voulez 
un exemple. Cela s'applique aussi à la documentation des bibliothèques de KDE 
qui utilise un type de documentation similaire ; c'est donc presque tout ce que 
vous avez à savoir sur l'utilisation des références (croisées) de classes dans 
le navigateur de documentation. 
<P>
<H4>Dissection de l'exemple </H4>

<P> 
En commençant par <CODE>QApplication</CODE>, vous trouverez toutes les méthodes 
utilisées dans notre premier exemple : 
<P>
<UL>
<LI>le constructeur <CODE>QApplication()</CODE></LI>
<LI>la méthode <CODE>setMainWidget()</CODE> et</LI>
<LI>la méthode <CODE>exec()</CODE>. </LI>
</UL>
 
<P>Disséquons l'utilisation de ces méthodes : 
<P>
<OL>
<LI>créer d'abord une instance de la classe <CODE>QApplication</CODE> avec le 
constructeur afin de pouvoir utiliser les éléments graphiques fournis par Qt </LI>
<LI>créer un widget qui sera le contenu de la fenêtre du programme</LI>
<LI>définir le widget comme widget principal pour <CODE>a</CODE></LI>
<LI>exécuter l'instance <CODE>a</CODE> de <CODE>QApplication</CODE>. </LI>
</OL>
 
<P>Le second objet de notre programme est le PushButton, une instance de la classe 
<CODE>QPushButton</CODE>.  
Nous utilisons le second des deux constructeurs donnés pour créer une instance ; ici, 
c'est la chaîne de caractères "Hello world!". Ensuite, nous avons appelé la méthode 
<CODE>resize()</CODE> pour changer la taille du bouton en fonction de son contenu - le bouton 
doit être agrandi pour que la chaîne apparaisse complètement. 
<P>Et la méthode <CODE>show()</CODE> ? Eh bien, vous constatez que, comme la plupart des autres 
widgets, <CODE>QPushButton</CODE> est basé sur un héritage simple - ici, la documentation 
indique <EM>Inherits</EM> <CODE>QButton</CODE>. Suivez le lien vers la classe 
<CODE>QButton</CODE>. Cela affiche beaucoup de méthodes qui sont héritées par 
QPushButton, que nous utiliserons plus tard pour expliquer le mécanisme signal/slot. 
De toute façon, la méthode <CODE>show()</CODE> n'est pas listée, c'est sûrement une méthode 
fournie par l'héritage. La classe dont hérite <CODE>QButton</CODE> est <CODE>QWidget</CODE>.
<P>Suivez à nouveau le lien et vous verrez un grand nombre de méthodes que la classe 
<CODE>QWidget</CODE> définit (dont la méthode <CODE>show()</CODE>). Maintenant, nous comprenons 
mieux ce qui s'est passé avec le bouton dans l'exemple : 
<P>
<OL>
<LI>créer une instance de <CODE>QPushButton</CODE>, utiliser le deuxième constructeur 
pour définir le texte du bouton  </LI>
<LI>redimensionner le widget pour que tout le texte qu'il contient apparaisse</LI>
<LI>définir le widget comme étant le widget principal de l'instance <CODE>a</CODE> de 
<CODE>QApplication</CODE></LI>
<LI>dire au widget de s'afficher sur l'écran en appelant <CODE>show()</CODE>, une méthode 
héritée de  <CODE>QWidget</CODE>. </LI>
</OL>
 
<P>Après l'appel à la méthode <CODE>exec()</CODE>, l'application est visible pour l'utilisateur, 
elle a dessiné une fenêtre avec le bouton affichant "Hello world!". Par contre, les 
programmes graphiques se comportent un peu différemment des applications procédurales. 
Ici, le point essentiel est que l'application entre dans une "boucle d'événements principale". 
Cela signifie que le programme doit attendre des actions de l'utilisateur et ensuite y réagir. 
Pour une application Qt, le programme doit être dans la boucle d'événements 
principale pour commencer à traiter les événements. La section suivante vous explique 
brièvement ce que cela signifie pour le programmeur et ce que Qt fournit pour 
traiter les événements utilisateur. 
<P>
<P>(Pour les utilisateurs déjà expérimentés : le bouton n'a pas de parent déclaré dans le 
constructeur, c'est donc un "top-level widget" seul et s'exécute dans une boucle 
d'événements locale qui ne nécessite pas d'attendre la boucle d'événements principale, 
voir la documentation de la classe <CODE>QWidget</CODE> et 
<A HREF="../kde_libref/index.html">le Guide de Référence des Bibliothèques de KDE</A>).
<P><B>Résumé :</B> 
<P>Une application Qt doit toujours avoir une instance de la classe 
<CODE>QApplication</CODE>. Cela garantit que nous pouvons créer des fenêtres qui 
sont la représentation graphique pour l'utilisateur et permettent d'interagir 
avec l'utilisateur. Le contenu de la fenêtre est appelé "Main Widget",
signifiant que tous les éléments graphiques sont basés sur la classe <CODE>QWidget</CODE> 
et peuvent être de n'importe quel type de widget correspondant aux besoins de
l'application pour interagir avec l'utilisateur. Aussi, tous les éléments
utilisateur doivent hériter de <CODE>QWidget</CODE> pour être visibles. 
<P>
<P>
<H4><A NAME="User Interaction"></A> Interaction avec l'Utilisateur </H4>

<P> 
Après avoir lu les dernières sections, vous devriez déjà savoir : 
<UL>
<LI>ce que fournit la bibliothèque Qt en termes d'applications graphiques </LI>
<LI>comment un programme utilisant Qt est créé</LI>
<LI>où et comment chercher des informations, avec le navigateur de documentation, 
sur les classes que vous voulez utiliser.</LI>
</UL>
 
<P>Maintenant, nous allons commencer à donner de la "vie" à l'application en traitant 
les événements utilisateur. Généralement, l'utilisateur a deux façons d'interagir 
avec un programme : la souris et le clavier. Pour tous les deux, une interface 
graphique utilisateur doit fournir des méthodes qui détectent les actions et des 
méthodes qui font quelque chose en réaction à ces actions. 
<P>Pour cela, le système de fenêtrage (NdT : Window system) envoie tous les événements 
d'interaction à l'application correspondante. La QApplication les envoie ensuite 
à la fenêtre active sous la forme d'un <CODE>QEvent</CODE> et les widgets eux-mêmes 
doivent décider ce qu'ils veulent en faire. Un widget reçoit l'événement et traite 
<CODE>QWidget</CODE>::<CODE>event(QEvent*)</CODE>, qui décide ensuite quel événement 
doit être exécuté et comment réagir ; event() est donc le gestionnaire d'événement 
principal. Ensuite, la fonction <CODE>event()</CODE> passe l'événement à des filtres d'événements 
qui déterminent ce qui s'est passé et quoi faire avec l'événement. Si aucun filtre n'est 
responsable de l'événement, les gestionnaires d'événements spécialisés sont appelés. Nous 
pouvons alors décider entre : 
<P><B>a) Événements clavier -- touches TAB et Shift-TAB :</B> 
<P>change le focus d'entrée du clavier du widget courant vers le widget suivant dans 
l'ordre du focus. Le focus peut être défini en appelant 
<CODE>setFocusPolicy
<!--
setFocusPolicy()
-->
()</CODE> et traitant les gestionnaires d'événements : 
<P>
<UL>
<LI><CODE>virtual void focusInEvent
<!--
focusInEvent()
-->
 ( QFocusEvent * )</CODE> </LI>
<LI><CODE>virtual void focusOutEvent
<!--
focusOutEvent()
-->
 ( QFocusEvent * )</CODE> </LI>
</UL>
 
<P><B>b) toutes les autres entrées du clavier :</B> 
<UL>
<LI><CODE>virtual void keyPressEvent
<!--
keyPressEvent()
-->
 ( QKeyEvent * )</CODE> </LI>
<LI><CODE>virtual void keyReleaseEvent
<!--
keyReleaseEvent()
-->
 ( QKeyEvent * )</CODE> </LI>
</UL>
 
<P><B>c) mouvements de la souris :</B> 
<UL>
<LI><CODE>virtual void mouseMoveEvent ( QMouseEvent * )</CODE> </LI>
<LI><CODE>virtual void enterEvent ( QEvent * )</CODE> </LI>
<LI><CODE>virtual void leaveEvent ( QEvent * )</CODE> </LI>
</UL>
 
<P><B>d) actions des boutons de la souris :</B> 
<UL>
<LI><CODE>virtual void mousePressEvent ( QMouseEvent * )</CODE> </LI>
<LI><CODE>virtual void mouseReleaseEvent ( QMouseEvent * )</CODE> </LI>
<LI><CODE>virtual void mouseDoubleClickEvent ( QMouseEvent * )</CODE> </LI>
</UL>
 
<P><B>e) événements de la fenêtre contenant le widget :</B> 
<UL>
<LI><CODE>virtual void moveEvent ( QMoveEvent * )</CODE> </LI>
<LI><CODE>virtual void resizeEvent ( QResizeEvent * )</CODE> </LI>
<LI><CODE>virtual void closeEvent ( QCloseEvent * )</CODE> </LI>
</UL>
 
<P>Remarquez que toutes les fonctions d'événements sont virtuelles et protégées ; ainsi, 
vous pouvez ré-implanter les événements dont vous avez besoin dans vos propres widgets 
et spécifier comment votre widget doit réagir. <CODE>QWidget</CODE> contient aussi 
d'autres méthodes virtuelles qui peuvent être utiles dans vos programmes ; en règle
générale, il est suffisant de bien connaître <CODE>QWidget</CODE>. 
<P>
<H4>Interaction entre Objets par Signal et Slot </H4>

<P> 
Nous arrivons maintenant à l'avantage le plus évident de la boîte à outils Qt : 
le mécanisme signal/slot. Il offre une solution très pratique et utile pour l'interaction 
entre objets, qui est souvent réalisée par des fonctions <CODE>callback</CODE> par les boîtes à 
outils pour X-Window. Comme cette communication nécessite une programmation stricte et 
rend parfois la création d'interfaces utilisateur très difficile (comme indiqué par la
documentation de Qt et expliqué dans <EM>Programmer avec Qt</EM> par K.&nbsp;Dalheimer), 
Troll Tech a inventé un nouveau système où les objets peuvent émettre des signaux qui 
sont connectés à des méthodes déclarées comme des slots. Du point de vue du 
programmeur C++, celui-ci a seulement peu de choses à savoir sur le mécanisme : 
<P>
<OL>
<LI>la déclaration d'une classe utilisant des "signaux/slots" doit contenir
la macro <CODE>Q_OBJECT</CODE> au début (sans le point-virgule) et doit dériver de la 
classe <CODE>QObject</CODE></LI>
<LI>un signal peut être émis par le mot-clé <CODE>emit</CODE>, exemple <CODE>emit signal(parameters);</CODE> 
de l'intérieur de n'importe quelle fonction membre d'une classe qui autorise les 
signaux/slots</LI>
<LI>tous les signaux utilisés par les classes qui ne sont pas héritées doivent être 
ajoutés dans la déclaration de la classe par une section <CODE>signals:</CODE></LI>
<LI>toutes les méthodes qui peuvent être connectées à un signal sont déclarées dans des 
sections avec le mot-clé supplémentaire <CODE>slot</CODE>, exemple : <CODE><B>public</B> slots:</CODE> dans 
la déclaration de la classe</LI>
<LI>le compilateur de méta-objet <CODE>moc</CODE> doit être exécuté sur le fichier d'en-tête pour 
traiter les macros et produire l'implantation (mais le savoir n'est pas vraiment 
nécessaire). Les fichiers générés par <CODE>moc</CODE> sont ensuite compilés par le compilateur C++. </LI>
</OL>
 
<P>Une autre façon d'utiliser les signaux sans hériter de <CODE>QObject</CODE> est d'utiliser la
classe <CODE>QSignal</CODE> - voir le manuel de référence pour plus d'informations et un exemple 
d'utilisation. Dans la suite, nous dériverons toujours de <CODE>QObject</CODE>. 
<P>De cette façon, votre classe est capable d'envoyer des signaux n'importe où et de
fournir des "slots" qui seront connectés à des signaux. Quand vous utilisez des signaux,
vous n'avez pas à vous soucier de qui les reçoit - vous émettez juste le signal et quelque 
soit le slot que vous y avez connecté, il peut réagir à l'émission. Par ailleurs, les slots 
peuvent aussi être utilisés comme des méthodes normales pendant l'implantation. 
<P>Maintenant, pour connecter un signal à un slot, vous devez utiliser les méthodes 
<CODE>connect()</CODE> qui sont fournies par <CODE>QObject</CODE> ou, lorsque c'est possible, des méthodes 
spéciales que des objets fournissent pour définir la connexion pour un certain signal. 
<P>
<P>
<H4>Exemple d'utilisation </H4>

<P> 
Pour expliquer la façon de définir une interaction entre objets, nous allons reprendre 
notre premier exemple et l'étendre avec une connexion simple : 
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
 
#include &lt;qapplication.h> 
#include &lt;qpushbutton.h> 
 
int main( int argc, char **argv ) 
{ 
QApplication a( argc, argv ); 
 
QPushButton hello( "Hello world!" ); 
hello.resize( 100, 30 ); 
 
a.setMainWidget( &amp;hello ); 
 
connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() )); 
 
hello.show(); 
return a.exec(); 
} 
</PRE>
<HR>
</CODE></BLOCKQUOTE>
 
<P>Vous voyez, le seul ajout pour donner plus d'interaction au bouton est d'utiliser une 
méthode <CODE>connect()</CODE> : 
<CODE>connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));</CODE> et c'est tout ce 
que vous devez ajouter. Qu'est-ce que cela signifie réellement&nbsp;? La déclaration de la 
classe <CODE>QObject</CODE> décrit ainsi la méthode <CODE>connect()</CODE> : 
<P><CODE>bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )</CODE> 
<P>Cela signifie que vous devez donner un pointeur sur une instance de QObject qui est 
l'émetteur du signal, ce qui veut dire qu'il peut émettre ce signal comme premier paramètre. 
Ensuite, vous devez spécifier le signal auquel vous voulez vous connecter. Les deux derniers 
paramètres sont l'objet receveur qui fournit un slot, suivi de la fonction membre qui, 
en fait, <EM>est</EM> le slot qui sera exécuté lors de l'émission du signal. 
<P>En utilisant des signaux et des slots, les objets de votre programme peuvent
interagir facilement les uns avec les autres sans dépendre explicitement du type de 
l'objet receveur. Vous en apprendrez plus sur l'utilisation de ce mécanisme pour un 
usage intensif dans la suite de ce manuel.
Plus d'informations sur le mécanisme Signal/Slot peuvent être trouvées dans 
<A HREF="../kde_libref/index.html">Le Guide de Référence des Bibliothèques de KDE</A> 
et dans le Manuel de Référence de Qt. 
<P>
<H3><A NAME="ss2.2">2.2 Ce que fournit KDE </A>
</H3>

<P> 
<H4>Les bibliothèques de KDE 1.1.x </H4>

<P> 
Au moment d'écrire ce manuel, et du fait que KDevelop utilise KDE 1.1, je me réferre à 
l'état des bibliothèques de KDE dans cette version. Les principales 
bibliothèques de KDE que vous allez utiliser pour créer vos propres applications KDE 
sont&nbsp;: 
<P>
<UL>
<LI>la bibliothèque KDE-Core, contenant toutes les classes qui sont des éléments non 
visibles et fournit des fonctionnalités que votre application pourrait utiliser </LI>
<LI>la bibliothèque KDE-UI, contenant des éléments d'interface utilisateur
comme les barres de menus, les barres d'outils, etc</LI>
<LI>la bibliothèque KFile, contenant les boîtes de dialogue de sélection de fichier.</LI>
</UL>
   
En plus, pour des applications spécifiques, KDE fournit les bibliothèques suivantes : 
<P>
<UL>
<LI>la bibliothèque KHTMLW, contenant un widget complet interprétant du HTML, qui est 
utilisé dans différents programmes comme KDEHelp, KFM ou KDevelop</LI>
<LI>la bibliothèque KFM, permettant d'utiliser le gestionnaire de fichiers de KDE à 
l'intérieur de n'importe quelle application</LI>
<LI>la bibliothèque KAB, le KAddressBook. Elle fournit un accès au carnet d'adresses 
pour des applications telles que les clients de messagerie</LI>
<LI>la bibliothèque KSpell, contenant des widgets et des fonctionnalités pour intégrer
l'utilisation d'Ispell, le vérificateur d'orthographe, dans des applications comme les 
éditeurs (utilisée notamment dans l'application KEdit). </LI>
</UL>
 
<P>Maintenant, nous allons regarder ce qui doit être fait pour convertir notre 
application Qt  en une application KDE. 
<P>
<H4>Exemple d'Application KDE </H4>

<P> 
Dans la suite, vous allez voir qu'écrire une application KDE n'est vraiment pas plus 
difficile que d'écrire une application Qt. Pour accéder aux fonctionnalités de KDE, 
vous devez seulement utiliser quelques classes supplémentaires et c'est presque tout. 
Comme exemple, nous allons traiter la version modifiée de l'exemple de Qt utilisé 
précédemment : 
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
 
#include &lt;kapp.h> 
#include &lt;qpushbutton.h> 
 
int main( int argc, char **argv ) 
{ 
KApplication a( argc, argv ); 
 
QPushButton hello( "Hello world!" ); 
hello.resize( 100, 30 ); 
 
a.setTopWidget( &amp;hello ); 
 
connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() )); 
 
hello.show(); 
return a.exec(); 
} 
</PRE>
<HR>
</CODE></BLOCKQUOTE>
 
<P>D'abord, vous voyez que nous avons changé <CODE>QApplication</CODE> en <CODE>KApplication</CODE>. 
Ensuite, nous avons du changer la méthode <CODE>setMainWidget()</CODE> précédemment utilisée en
<CODE>setTopWidget</CODE> que <CODE>KApplication</CODE> utilise pour définir le widget principal. 
C'est fini ! Votre première application KDE est prête - vous devez seulement indiquer au 
compilateur les chemins menant aux fichiers "include" de KDE et à l'éditeur de liens de 
lier la bibliothèque KDE-Core avec -lkdecore. 
<P>Comme vous savez déjà ce que la fonction main() fait généralement et comment une 
application devient visible et permet les interactions avec l'utilisateur et entre 
objets, nous allons passer au chapitre suivant où nous réaliserons notre première 
application avec KDevelop - là, vous pourrez aussi tester tout ce qui a été mentionné 
précédemment et en voir les effets. 
<P>Nous vous conseillons aussi de compléter ce chapitre en approfondissant le manuel de 
référence de Qt, et plus spécialement les classes <CODE>QApplication</CODE>, 
<CODE>QWidget</CODE> et <CODE>QObject</CODE>, ainsi que la documentation de la classe 
<CODE>KApplication</CODE> de la bibliothèque KDE-Core. Le manuel de 
<A HREF="../kde_libref/index-3.html">Référence des Bibliothèques de KDE</A> 
donne aussi une description complète sur l'appel des constructeurs de <CODE>QApplication</CODE> 
et <CODE>KApplication</CODE>, y compris le traitement des arguments de la ligne de commande. 
<P>
<P ALIGN="RIGHT">

<A HREF="index-3.html">Page suivante</A>
 <A HREF="index-1.html">Page précédente</A>
 <A HREF="index.html#toc2">Table des matières</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
