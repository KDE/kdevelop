<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDE Anwendungs Tutorials: Anwendungs Konzepte</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-7.html">Weiter</A>
 <A HREF="index-5.html">Zurück</A>
 <A HREF="index.html#toc6">Inhaltsverzeichnis</A>
</P>
<H3><A NAME="s6">6. Anwendungs Konzepte</A></H3>

<P>Dieses Kapitel stellt Ihnen die Ideen der bereits erwähnten Applikationsmodelle vor: das MDI (Multiple Document Interface) und das 
Document View Modell. Eine Basiseinführung in das Doc-View Modell und die Generierung eines Projektes mit KDevelop ist schon in 
<A HREF="../programming/index.html">The KDevelop Programming Handbook</A> enthalten, aber auf Basis des Single Document 
Interface (SDI). In jedem Falle, sollten Sie mit den Grundlagen der KDE und Qt Klassen vertraut sein, die in 
<A HREF="../kde_libref/index.html">The KDE Library Reference Guide</A> erklärt sind, die Basisklassen der darunterliegenden 
Bibliotheken und ihre Verwendung werden dort im Detail beschrieben, außerdem finden Sie zusätzlich eine Beschreibung des Qt 
Signal-Slot Verfahrens und der Ereignisverarbeitung.
<P>Als Anhaltspunkt sollten Sie bereits wissen:
<UL>
<LI>Das jede KDE Applikation eine Instanz von <CODE>KApplication</CODE> (bei Qt eine Instanz von <CODE>QApplication</CODE>) benötigt</LI>
<LI>Generell ein Main Fenster von <CODE>KTMainWindow</CODE> bei KDE (for Qt von <CODE>QMainWindow</CODE>) abgeleitet ist</LI>
<LI>Das Ereignisse (z.B. Tastendrücke oder Mausbewegungen) von darunterliegenden Window System an die Anwendung gesendet 
werden</LI>
<LI>Das <CODE>QWidget</CODE> als Basisklasse für alle Graphical User Interface (GUI) Komponenten spezialisierte Event Handler durch 
virtuelle Functionen bereitstellt, die die entsprechenden Events durch Reimplementation von <CODE>QObject::event()</CODE> ausfiltern </LI>
<LI>Das das Qt Signal-Slot Verfahren bedeutet, das eine Komponente Signale aussendet und ein Empfänger sich mit diesen Signalen 
verbinden kann, um bestimmte Aktionen auszuführen.</LI>
<LI>Das dieser Mechanismus es unnötig macht, Klassen für GUI Komponenten zu beerben, weil die Signale Sie über z.B. 
Mausereignisse informieren, wo es passend für ein Widget ist.</LI>
</UL>
<P>
<H3><A NAME="ss6.1">6.1 Das Document-View Modell</A>
</H3>

<P>Das Document-View Modell ist eines der grundlegendsten Konzepte für Anwendungsdesign, das auf GUI basiert. Daher ist ein gewisses 
Verständnis für das Warum nötig, um zu sehen, daß es Sinn macht es zu benutzen, obwohl der Programmiere andere Möglichkeiten hat. 
Lassen Sie uns aber zuerst einen Blick auf das normale Design einer typischen KDE / Qt Applikation werfen:
<P>Die Instanz Ihrer Anwendung stellt die erste Verbindung zu Ihrer Applikation zu Verfügung und ist der Startpunkt der 
Ereignisbehandlung eines Programms. Das Programm selber präsentiert sich dem Benutzer über eine graphische Benutzerschnittstelle, 
die meisten Hauptfenster genannt wird. Das Hauptfenster stellt dann dem Benutzer die erforderlichen Funktionen zur Verfügung, wie 
Tastenkürzel, eine Menüleiste, eine Werkzeugleiste und eine Statuszeile. Im Zentrum befindet sich ein sogenannter 
"Ansichtsbereich", was bedeutet, daß dieser Bereich die Instanz einer anderen Klasse ist, normalerweise "Ansicht" genannt. Diese 
Instanz wird erzeugt, wenn das Hauptfenster beim Programmstart konstruiert wird und muß mit Hilfe einer Methode des Hauptfensters 
zum Ansichtsbereich gemacht werden: <CODE>setView(your_view)</CODE> bei KDE Applikationen die <CODE>KTMainWindow</CODE> verwenden,
<CODE>setCentralWidget(your_view)</CODE> bei Qt Applikationen die <CODE>QMainWindow</CODE> verwenden. Nun, offensichtlich is die Ansicht 
der Bereich, der verantwortlich für die Interaktion mit dem Benutzer ist, wenn die Daten, die er represäntiert manipuliert werden 
sollen. Zum Beispiel könnten Sie <CODE>QMultiLineEdit</CODE> als Ansicht verwenden, und Sie hätten einen Editor. Dann können Sie die 
gegebenen Slots der Ansicht zur Kommunikation mit der Menüleiste oder der Werkzeugleiste folgendermaßen verwenden:
<P>Während Sie die Menüleiste erstellen, möchten Sie eine Methode für das Kommando "Cut" im "Edit" Menü bereitstellen:
<BLOCKQUOTE><CODE>
<PRE>
  pEditMenu->insertItem(BarIcon("editcut"), i18n("Cu&amp;t"),view, SLOT(cut()),KAccel::Cut, ID_EDIT_CUT);
</PRE>
</CODE></BLOCKQUOTE>
<P>Dies erzeugt einen Menüeintrag im "Edit" Menü, der, wenn aktiviert, direkt den Slot <CODE>cut()</CODE> der Instanz 
<CODE>view</CODE> aufruft, wobei wir davon ausgehen, daß Sie diese Instanz als <CODE>QMultiLineEdit</CODE> erzeugt und sie zum 
Ansichtsbereich gemacht haben. Der Slot des MultiLineEdit wird aufgerufen und schneidet als Reaktion den ausgewählten Text aus, 
die Funktionalität dazu wird bereits von der Klasse selbst zur Verfügung gestellt, es gibt also keine Notwendigkeit von 
<CODE>QMultiLineEdit</CODE> zu erben, um einen Ansichtsbereich zu erzeugen, der fähig zu solchen Aktionen ist. Diese Funktionen können 
sofort aufgerufen werden und machen das Erstellen von Anwendungen sehr schnell- Sie brauchen nur die Anwendungsinstanz und das 
Hauptfendter mit den Verbindungen zu Ihrem Ansichtsbereich und das ist alles ! Das bedeutet, ein einfacher Editor kann geschrieben 
werden, indem man eine einzige Klasse erzeugt, die das Hauptfenster definiert und wie man Datei in und aus dem Editor schreibt und 
ließt- nur einige Basisslots die Ihre Hauptansicht selbst implementieren muß. 
<P>Aber hier ist nun der Grund für dieses mysteriöse Document-View Modell: Sie müssen selbst Methoden zur Verfügung stellen, um die 
Dateien, die Sie mit dem <CODE>QMultiLineEdit</CODE> Ansichtsbereich lesen und schreiben zu können, und zwar <B>innerhalb</B> des 
Hauptfensterinterfaces. Ja, das ist offensichtlich der einfachste Weg und der logischste. Nun, wenn die Dateien und ihren Inhalt 
als ein sogenanntes "Dokument" betrachten, das wir mit dem Attribut eines "Objektes" in der C++ Terminologie beschreiben, ist der 
nächste Schritt nur ein kleiner: Ich habe ein Dokument, eine Ansicht und ein Hauptfenster- warum trenne ich diese drei Objekte 
nicht voneinander? Wir könnten auf einfache Weise eine kleine Klasse erzeugen, die eine Datei in einen Text Stream ließt und dann 
die Ansicht aufrufen, um diesen Text für den Benutzer sichtbar zu machen. Dasselbe gilt auch wieder für das Speichern der Datei- 
Die document Klasse sollte dann eine Methode anbieten, den Text aus der Ansicht zu lesen und als Datei zu speichern. im Beispiel 
wären diese beiden Methoden die einzigen Aktionen die von der document Klasse ausgeführt werden müssten, weil die Edit Ansicht 
bereits alle Methoden über Slots bereitstellt, die für einen Editor benötigt werden, und Sie können den Inhalt der Ansicht direkt 
über diese Slots manipulieren. 
<P>Nun, die Haupidee hinter dieser Aufteilung in drei Objekte (Dokument, Ansicht, Hauptfenster) anstatt der minimal zwei, der Ansicht 
und dem Hauptfenster, ist folgende Frage: Was, wenn ich dem Benutzer die Möglichkeit geben will mit <B>zwei</B> oder sogar mehr 
Ansichten zu arbeiten? Solche Dinge kann man sogar mit nur einem Hauptfenster durch Trenner erreichen, wobei zwei Instanzen 
<B>einer</B> Datei angezeigt werden. Die Lösung kann dann nur sein, daß wenn der Benutzer den Dateiinhalt in einem Fenster 
verändert, die andere Ansicht darüber informiert wird und ihren Inhalt aktualisieren muß. Sonst würde folgendes passieren: Wenn 
der Benutzer in einer Ansicht am Anfang etwas ausschneidet, dann am Ende der <B>anderen</B> Ansicht einfügt und dann die erste 
Ansicht schließt, würde die Datei mit beiden Teilen gespeichert, weil die zweite Ansicht nichts von dem Ausschneiden weiß. Das 
bedeutet, daß die beiden Asichten synchronisiert werden müssen und das kann erreicht werden, indem alle Ansichten ständig über 
alle Benutzeraktionen informiert werden, welche Ansicht der User tatsächlich verwendet sollte egal sein. Das bedeutet, daß 
schließlich eine Dokumentklasse benötigt wird, die alleine den wahren Inhalt des Dokumentes enthält und den Ansichten die 
Möglichkeit bietet, diesen zu verändern.
<P>Ich hoffe, dies konnte einen Einblick in dieses Modell geben, obwohl es in den meisten Fällen so scheint, als ob der Programmierer 
ohne es leben könne- genauso könnte er auch ein Widget selber schreiben, das die Benutzeraktionen behandelt, anstatt einfach eine 
vorgebene Klasse als Ansichtsbereich zu verwenden, solange Sie nur <B>ein</B> Dokument in <B>einem</B> Ansichtsbereich 
präsentieren, kann die Ansicht auch für die Daten verantwortlich sein und nur Methoden zum Lesen oder Speichern einer Datei zur 
Verfügung stellen. Das nächste beschriebene Modell wird sich in diesem Punkt unterscheiden- dort werden Sie die tatsächliche 
Notwendigkeit und die Funktionalität, die die Document Klasse bereitstellt, erkennen.
<P>
<H3><A NAME="ss6.2">6.2 Das Multiple Document Interface (MDI)</A>
</H3>

<P>Da der letzte Abschnitt das Document View Modell beschrieben hat, können Sie sicher erraten, was MDI bedeutet. Benutzer die von 
anderen Plattformen als Unix/Linux kommen, sowie die Programmierer, die für diese Plattformen entwickeln, sind daran gewöhnt. Da 
X-Window Applikationen traditionell mehr auf Funktionalität und Stabilität abzielen, sind Unix Anwender an einzelne Fenster 
gewöhnt, die Funktionalität bieten, weshalb oft nicht einmal das Document View Modell benötigt wird um Anwendungen zu erstellen. 
Mit Qt als Multi-Platform Werkzeug, haben Entwickler sogar noch mehr Auswahl- die Entwicklung für sowohl Unix, als auch 
MS Windows(tm). Während auf Windows Applikationen, die sogenannte Kind Fenster verwalten können zu einer Art Standard geworden 
sind, darauf zielt die Qt 2.1 Bibliothek ab, können auch Unix Benutzer von dieser Architektur profitieren. 
<P>Was ist nun die Bedeutung von MDI? Eine MDI Applikation hat das gleiche Konzept, wie eine gewöhnliche Anwendung, die, wie oben 
beschrieben, eine Anwendungsinstanz und ein Hauptfenster hat. Der Ansichtsbereich macht nun den Unterschied: Sie verwenden nicht 
direkt eine Ansicht, die Daten repräsentiert und Interaktion zur Manipulation der Daten bereitstellt, sondern eine Ansicht, die 
andere Fenster verwaltet, die wie top-level Fenster aussehen. Diese Fenster repräsentieren nun den ehemaligen Ansichtsbereich und 
der Hauptunterschied ist, daß die Interaktionskette sich von
<P>
<BLOCKQUOTE><CODE>
<PRE>
Applikations Instanz -> Hauptfenster -> Ansicht

nach

Applikations Instanz -> Hauptfenster -> Ansicht -> Aktives Kind Fenster
</PRE>
</CODE></BLOCKQUOTE>

ändert.
<P>Die Ansicht beherrscht nun verschiedene Aktionen:
<UL>
<LI>Erzeugen von so vielen Kind Fenstern, wie der Benutzer anfordert</LI>
<LI>Zur Verfügung stellen von Methoden, zur Ermittlung des aktiven Kind Fensters</LI>
<LI>Verwaltung einer Liste offener Ansichten</LI>
<LI>Verwaltung das Verhalten des Kind Fensters bei maximieren, minimieren, so wie es der Fenstermanager für to-level 
Fenster macht</LI>
</UL>
 
<P>Nun, Sie können komplette Widgets wie <CODE>QMultiLineEdit</CODE> als Kind Fenster für Anwendungen verwenden, die nur ein Fenster 
bereitstellen und jedes Fenster ist für seine eigenen Daten verantwortlich. Dies könnte als Multiple Document Interface 
beschrieben werden, wobei jedes Fenster wie ein einzelnes Dokument ist. Die Anwendung verwaltet dann die üblichen Aktionen, wie 
bereitstellen von Methoden zur Interaktion, wie Ausschneiden und Kopieren. Die Erweiterungen dieses Konzepts um das Document View 
Modell, verbessert die Möglichkeiten bei weitem: stellen Sie sich vor, daß Sie innerhalb des Haupfensters so viele Fenster öffnen 
können wie Sie wollen und das ein Kind Fenster, die neue Ansicht eines Dokuments sein kann, das bereits in einem anderen Kind 
Fenster gezeigt wird. Die Verwaltung hierfür macht die schon beschriebene Aufteilung in das drei Objekte Modell nötig, aber 
limitiert weder die Anzahl der tatsächlichen Instanzen noch die der Ansichten.
<P>Glücklicherweise enthält Qt 2.1 die Möglichkeit solche Anwendungen zu schreiben und KDevelop bietet Ihnen die entsprechenden 
Anwendungsschablonen für beides, sowohl nur-Qt Programme als auch KDE 2 Programme mit denselben Interface Methoden- Sie können 
also beide Typen adequat erstellen. Die Verwendung des KDE 2 Interfaces bietet Ihnen sogar noch mehr Möglichkeiten durch 
Bibliotheksfunktionen sowie Interprozesskommunikation, dies sind jedoch spezielle Aspekte die durch separate Einführungen 
abgedeckt werden müssen.
<P>Sie sind nun vorbereitet der Entwicklung für KDE 2 zu folgen- folgen Sie einfach dem nächsten Kapitel, um einen ersten Einblick in 
die Funktionalität zu erhalten, die bereits von KDevelop zur Verfügung gestellt wird, wenn sie Anendungen erstellen. Dort werden 
wir das Framework für unsere Beispielanwendung <EM>KScribble</EM> generieren und die praktischen Aspekte der Programmierung von MDI 
Applikationen beschreiben.
<P>
<P>
<P ALIGN="RIGHT">

<A HREF="index-7.html">Weiter</A>
 <A HREF="index-5.html">Zurück</A>
 <A HREF="index.html#toc6">Inhaltsverzeichnis</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
