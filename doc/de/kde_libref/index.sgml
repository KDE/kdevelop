
<!doctype linuxdoc system>
<book>
<title>Das KDE Bibliotheks-Handbuch
<subtitle>Die Referenz zum Anwendungsdesign für das K Desktop Environment (KDE)
<author>Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name = "<Ralf.Nolden@post.rwth-aachen.de>">
<inst>Das KDevelop Team
<date>Version 1.0 , 28.Juli 1999
<abstract>
Dieses Handbuch ist Teil der KDevelop Entwicklungsumgebung und ist ebenfalls unter der GNU General Public License lizensiert
; siehe Kapitel <ref id="Copyright" name="Copyright"> für weitere Informationen.
</abstract>

<toc>

<chapt>Einführung
<p>
<sect>Was KDE bietet
<p>
Das K Desktop Environment bietet Anwendungsentwicklern einen einfachen Weg, ihre Produkte mit einer intuitiven Benutzerführung
auszustatten. Es stellt alle Mittel zur Verfügung, um gewöhnliche Aufgaben mittels einer Klassenbibliothek, die die Fähigkeiten von
Qt erweitert,zu lösen. Dies ermöglicht eine einheitliche Bedienung (look and feel) von Anwendungen und die Interaktion mit anderen
Programmen und dem Window Manager. Dieses Handbuch gibt eine Einführung in die Benutzung der KDE Bibliotheken, die in KDE enthalten
sind, um Entwicklern zu einfachen Lösungen ihrer üblichen Programmieraufgaben zu verhelfen. Es erklärt zudem, warum bestimmte
Techniken und Klassen verwendet werden sollten, um Anwendungen für das K Desktop Environment zu entwickeln.  
Einfach gesagt bietet KDE Standards, die ein einheitliches Aussehen und eine einheitliche Bedienung von Anwendungen erlauben, wie sie
bei der Erstellung von Programmen beachtet werden sollten. Viele Aufgaben werden automatisch gelöst, wie z.B.:

<itemize>
<item>Session Management
<item>Konfiguration von Tastaturkürzeln
<item>Wechsel von Zeichensatz, Stil und Farbe
<item>Unterstützung von Themes (KDE 1.1.2 und höher)
<item>Internationalisierung
</itemize>

Aus diesem Grund werden diese Themen nur bezüglich ihrer Funktionalität erwähnt um eine vollständige Information zu gewährleisten.
Anwendungsentwickler müssen sich lediglich darum kümmern, was ihr Programm tun soll und an welcher Stelle KDE hier helfen kann.
Hier stellt KDE Benutzerschnittstellen zur Verfügung die die des Qt Toolkits erweitern, wo dies nötig ist. Wenn beide Bibliotheken
gleich gute Lösungen anbieten, sollten KDE-Entwickler (in den meißten Fällen) die Möglichkeiten der KDE-Bibliotheken nutzen.
KDE stellt eine Anzahl an Widgets zur Verfügung, die zur Erstellung von anwendungsspezifischen Dialogen und Ansichten genutzt werden
können. Beispiele sind:
<itemize>
<item>KSeparator, bietet einen üblichen Trennstrich
<item>KColorButton, bietet einen Button mit variabler Farbe
</itemize>

Normalerweise verlangen Anwendungen vom Benutzer die Angabe verschiedener Werte. Hier bieten die Bibliotheken  die Möglichkeit,
vorgefertigte, komplexe Widgets zu benutzen, die dem KDE-Benutzer bereits bekannt sind, wie z.B.:

<itemize>
<item>Dateidialoge,
<item>Farbauswahldialoge,
<item>Zeichensatzdialoge,
<item>Dialoge zur Tastaturkonfiguration
</itemize>

Diese sollten genutzt werden, wo auch immer eine Benutzereinstellung vonnöten ist, da es die Arbeit des Programmierers erleichtert,
die Möglichkeiten der Anwendung drastisch verbessert und ein einheitliches Aussehen vermittelt.

Die Qt-Bibliothek ist in diesem Handbuch erwähnt, wo immer sie Möglichkeiten bietet, die von KDE nicht zur Verfügung gestellt werden.
Da jedoch Informationen über das Event Handling und die Signal/Slot-Mechanismen für Entwickler schwer zu finden sind, wird diesem
Thema ein eigenes Kapitel in diesem Handbuch gewidmet.

<sect>Anmerkungen zu KDE 2 / Qt 2.0
<p>
Wie Sie vielleicht schon vermutet haben, behandelt dieses Handbuch <bf/ausschließlich/ die Entwicklung unter <bf/KDE 1.x/ unter
Verwendung der <bf/Qt 1.4x/-Bibliotheken. Sie werden vielleicht fragen "Qt Version 2.0 ist bereits erschienen, warum wird nicht
ausschließlich dieses besprochen ?" - aber es gibt Gründe für eine KDE 1.x Referenz.

Diese Gründe sind zuerst einmal, daß Entwickler die KDE 1.x Serie als stabilen Desktop und Entwicklungsumgebung betrachten sollten.
Solange KDE 2 (welches dann auch Qt 2.0 einführen wird) sich in der Entwicklung befindet, werden es Programmierer nicht leicht haben,
den ständigen Änderungen zu folgen, die eine zeitaufwendige Recherche und, beim Auftreten von Fehlern, eine langwierige Fehlersuche 
zur Folge haben. Es gibt Projekte des KDE Kernteams, die sicherstellen sollen, daß die KDE 2 Bibliotheken funktionieren werden - KDE
selbst genauso wie die KOffice Suite. Trotzdem, Entwickler die jetzt anfangen, KDE-Projekte zu entwickeln oder dies bereits tun,
haben jetzt die Auswahl. Diejenigen, die Wert auf eine stabile Umgebung haben, werden ihre Applikationen ebenfalls auf KDE 2.0
portieren wollen, einerseits um sie benutzbar zu machen, andererseits um Erweiterungen der neuen Bibliotheksfunktionen nutzen zu
können. Daher sind and den Stellen, wo KDE und Qt sich von zukünftigen Versionen unterscheiden, Fußnoten hinzugefügt worden, soweit
diese dem Autor zum Zeitpunkt der Erstellung diese Dokumentation bekannt waren und erheben daher keinen Anspruch auf Vollständigkeit.
Klassen, die in der momentanen KDE 2 API bereits entfernt wurden, sind hier nicht mehr erklärt, um Schwierigkeiten bei einer späteren
Portierung nach KDE 2 zu vermeiden.

In späteren Versionen dieses Handbuchs wird auf die Entwicklung für KDE 2 vollständig eingegangen und die entsprechenden Kapitel
geändert, wo dies nötig wird.

<sect>Über dieses Handbuch
<p>
Dieses Handbuch wurde geschrieben, um Entwicklern eine Richtlinie über die Benutzung der KDE 1.x Bibliotheken in Verbindung mit der
Qt 1.4x Bibliothel auf X11-Desktopsystemen an die Hand zu geben. Es kann keine Kentnisse über die C++ Programmierung und die
Qt-Klassen, wo diese benötigt werden, ersetzen. Sie sollten sich in jedem Fall die Seite "Structure Overview" der Qt-Onlinereferenz
ansehen, die einen generellen Überblick über die Qt-Bibliothek und die allgemeine Benutzung der Klassen gibt. Dieses Handbuch
versucht dieser Struktur zu folgen um Ihnen zu vermitteln, wo KDE-Klassen sinnvoll sind und erklärt die Technik der
Anwendungsentwicklung unter KDE, indem es die Anwendung der Klassen für bestimmte Ziele erläutert.


<chapt>Klassen Kategorien
<p>
Die KDE/Qt C++ Klassen-Bibliotheken bieten einfache Lösungen um Anwendungen dramatisch zu erweitern, mit einem minimalen Aufwand auf
Seiten des Programmieres. Dieses Kapitel ordnet die zur Verfügung gestellten Klassen bezüglich ihrer Benutzung in bestimmte
Kategorien:

<itemize>
<item>Basisklassen
<item>Anwendungsarchitektur-Klassen
	<itemize>
	<item>Anwendungsobjekte von  KDE
	<item>Anwendungskonfiguration
	<item>Hauptfenster
	</itemize>
<item>Benutzerinterface-Objekte
	<itemize>
	<item>Ansichten
	<item>Dialoge
	<item>Kontrollelemente
	<item>Menüs
	</itemize>
<item>Allgemeine Klassen
	<itemize>
	<item>Dateien
	<item>Datenobjekte
	<item>Grafik
	<item>Prozesse
	</itemize>
</itemize>

<sect>Basisklassen
<p>

Die meißten KDE/Qt-Klassen haben <tt/QObject/ als ihre Basisklasse in ihrer Vererbungshierarchie. <tt/QObject/ kann man als
Basisklasse bezeichnen, da sie die Nutzung von Qt's signal/slot Mechanismen ermöglicht, welche die Interaktion von Objekten innerhalb
der Anwendung erlauben und sollte als Basisklasse für jede selbsterstellte Klasse, die Signale aussenden oder sich über Slots an
Signale binden können soll, genutzt werden.

<sect>Anwendungsarchitektur-Klassen
<p>
KDE-Anwendungen bestehen gewöhnlich aus einer Anzahl Objekte, die miteinander interagieren. Der Programmierer kann die zur Verfügung
gestellten Klassen nutzen, um eine KDE-Anwendung zu erstellen, entweder durch Instanzierung oder durch Vererbung. Eine typische
Anwendung enthält:

<itemize>
<item>Ein Anwendungsobject des Typs <tt/KApplication/
<item>Eine Hauptfensterklasse, abgeleitet von <tt/KTMainWindow/
<item>Eine Klasse, abgeleitet von <tt/QWidget/ um die Anwendungssicht zu erzeugen
</itemize>


<sect>Anwendungsobjekte von KDE
<p>
Das K Desktop Environment bietet Funktionen, die von einer Anwendung benutzt werden können, um sich in KDE zu integrieren. Diese
Funktionalität ist in der Klasse <tt/KApplication/ implementiert und sollte daher als Basisklasse für jede KDE-Anwendung benutzt
werden. Eine KDE-Anwendung beinhaltet nur ein Objekt der Klasse <tt/KApplication/. Dieses wird in der <tt/main()/-Funktion der
Anwendung erstellt.  Das Objekt des Typs <tt/KApplication/ ist dafür verantwortlich, das grundlegende Benutzerinterface, bezogen auf
den Desktop, zur Verfügung zu stellen und die Kommandozeilenargumente auszuwerten. Da diese Instanz nicht sichtbar, jedoch das
Hauptobjekt der Anwendung ist, müssen folgende Regeln beachtet werden:

<itemize>
<item>die Anwendung wird beendet mit <tt/kapp->quit()/.
<item>das Objekt, das die grafische Schnittstelle repräsentiert, muß als Hauptwidget mit <tt/setTopWidget()/ gesetzt werden (für
widgets, die nicht von <tt/KTMainWindow/ abgeleitet sind)
</itemize>

Das <tt/KApplication/-Objekt bietet:
<itemize>
<item>Zugriff auf das KDE Filesystem
<item>ein Objekt zur Sitzungskonfiguration
<item>ein Konfigurationsobjekt
<item>Internationalisierung durch das Objekt locale
<item>Veränderung der sichtbaren Objekte durch Signale
</itemize>
<footnote>KDE 2 greift auf die entsprechenden Instanzen durch statische Methoden zu, die von <tt/KGlobal/ zur Verfügung gestellt
werden.</footnote>


<bf/Abhängigkeiten:/ -lkdecore -lqt

<bf/Includes:/ <tt/#include &lt;kapp.h&gt;/

Die <tt/kdeui/-Bibliothek bietet zusätzlich zwei Klassen für bestimmte Zwecke, die von <tt/KApplication/ abgeleitet sind:

<sect1>KWMModuleApplication
<p>
<bf/Includes:/ <tt/#include &lt;kwmmapp.h&gt;/

<bf/Abhängigkeiten:/ -lkdeui -lkdecore -lqt

Die Klasse KWMModuleApplication ist die Basisklasse für KDE-Windowmanager-Module. Sie informiert ein Modul über alle zur Zeit
verwalteten Fenster und Änderungen an ihnen (durch Qt-Signale). Es gibt keine Methoden, um Fenster zu beeinflussen. Diese sind in der
Klasse KWM (siehe kwm.h) definiert. Ein Beispiel für die Benutzung von KWMModuleApplication ist kcontrol.

<sect1>KControlApplication
<p>

<bf/Includes:/ <tt/#include &lt;kcontrol.h&gt;/

<bf/Abhängigkeiten:/ -lkdeui -lkdecore -lqt

KControlApplication ist die Basis für Setup-Anwendungen. Es bietet einen tab (Kartenreiter)-Dialog und Funktionen, wie sie in den
meißten Setup-Programmen üblich sind. Die Konfigurationsdialoge von KDE sind Beispiele für KControlApplications.

<sect1>KWM
<p>
<bf/Includes:/ <tt/#include &lt;kwm.h&gt;/

<bf/Abhängigkeiten:/ -lkdeui -lkdecore -lqt

Die KWM-Klasse bietet eine Anzahl von statischen Methoden um mit dem Window- und Sessionmanager zu interagieren. Daher muß jedes
Mitglied diese Klasse mit 

KWM::&lt;method()&gt;

aufgerufen werden, abhängig vom Zweck der gewünschten Funktion.


<sect1>Anwendungs-Konfiguration
<p>

Die Klasse <tt/KConfig/ stellt ein Konfigurations-Objekt zur Verfügung, das seine Einträge in Konfigurationsdateien schreiben kann.
Abhängig von den Werten die Sie lesen und schreiben wollen, müssen Sie Methoden der Klasse <tt/KConfigBase/. nutzen.

Das <tt/KApplication/-Objekt stellt ein Applikations-Konfigurationsobjekt mit einer Ressourcedatei standardmäßig zur Verfügung,
welches im KDE-Verzeichnis des Benutzers abgelegt wird. Zudem wird eine Datei angelegt, die Informationen zum Sitzungsmanagement
zwischen einzelnen Sitzungen enthält.

Zur Internationalisierung nutzt das <tt/KApplication/-Objekt die Klasse <tt/KLocale/ um Einträge in der lokalen Sprache entsprechend
der gewählten Sprache zu übersetzen. Statt der <tt/klocale->translate()/-Methode sollten KDE-Anwendungen das <tt/i18n()/-Makro
benutzen, welches die zu übersetzende Zeichenkette enthält, da die Meldungserstellung auf diesem Makro aufbaut.

<sect1>Hauptfenster
<p>
Da die Instanz <tt/KApplication/ der Anwenung nicht sichtbar ist, stellt sie nur die grundsätzlichen Funktionen einer KDE-Anwendung
zur Verfügung. Daher muß jede KDE-Anwendung ein Haupfenster bseitzen, um sich dem Benutzer grafisch zu präsentieren. Das Hauptfenster
besteht im Normalfall aus einem Widget, welches im einfachsten Fall aus einem Button bis hin zum komplexesten Fall, dem
<tt/KTMainWindow/-Widget bestehen kann und alle notwendigen Funkionen für ein vollständiges Hauptfenster mit Geometrieverwaltung,
Sitzungsverwaltung, Menüleiste, Werkzeugleisten und einer Statuszeile zur Verfügung stellt.

Im Allgemeinen muß jedes Hauptfenster mit der Methode <tt/setTopWidget()/ von <tt/KApplication/ als Haupt-Widget gesetzt werden. Eine
Ausnahme bilden Hauptfenster die von <tt/KTMainWindow/ abgeleitet sind.

Das Hauptfenster ist üblicherweise für die Beendung der Anwendung verantwortlich, indem es eine Benutzerschnittstelle zur Verfügung
stellt, die mit <tt/KApplication::quit()/ verbunden ist und einfach durch <tt/kapp->quit()/ genutzt werden kann.

Die meißten KDE-Anwendungen werden <tt/KTMainWindow/ nutzen, um die Anwendung grafisch darzustellen.

<sect>Benutzerschnittstellen-Objekte
<p>
Dieser Abschnitt befasst sich mit Benutzerschnittstellen-Objekten, wie sie von den KDE-Bibliotheken zur Verfügung gestellt werden.
Diese können in Kategoriern, abhängig von ihrem Zweck, unterteilt werden. Eine Benutzerschnittstelle kann sein:

<itemize>
<item>ein Widget der Hauptansicht, welches die Daten, die durch die Anwendung erzeugt werden sollen dartellt und Methoden zu ihrer
Manipulation bietet.
<item>Dialoge, um Benutzereingaben abzufordern (z.B. ein Dateidialog)
<item>Kontrollelemente, um Anwendungsspezifische Widgets zu erzeugen.
<item>Menüs, die Benutzerschnittstellen zur Übermittlung von Kommandos an die Anwendung enthalten
</itemize>

<sect1>Ansichten
<p>
Ansichten stellen im Allgemeinen den Teil des Anwendungsfensters, der die Inhalte darstellt. Darum kann es sich um das Hauptwidget
oder einen Teil des Hauptwidgets handeln, der zusätzlich einige Funktionen bietet,wie z.B. <tt/KTMainWindow/.

Die KDE-Bibliotheken bieten eine Anzahl von vordefinierten Ansichten, von denen eigene abgeleitet werden können um die gewünschte
Funktionalität zu erreichen:

<itemize>
<item>KTabListBox: bietet eine Listbox mit mehreren Spalten, bei der der Benutzer die Zeilen mittels Drag'n Drop bearbeiten
kann.
<item>KEdit: Die Basisklasse von KEdit, wie es KDE beiliegt. Sie kann anstatt QMultiLineEdit benutzt werden.
<item>KNewPanner: verwaltet zwei Widgets ähnlich QSplitter
<footnote>Entfernt in KDE 2. QSplitter sollte stattdessen genutzt werden</footnote> 
<item>KHTMLView: Ein Widget, welches HTML interpretiert (khtmlw)
</itemize>

Um <tt/KTMainWindow/ zu benutzen, erstellen Sie die Instanz Ihrer Sicht und rufen Sie <tt/setView(QWidget*)/ auf, um die Verwaltung
durch die <tt/KTMainWindow/-Instanz zu erreichen.

Individuelle Ansichten werden gewöhnlich durch Vererbung von <tt/QWidget/ oder anderen zur Verfügung gestellten Widgets, die der
gewünschten Funktionalität am nächsten kommen, erstellt. Für Widgets, die die Fähigkeit zum Scrollen besitzen sollen, können Sie
diese von  <tt/QScrollView/ ableiten oder eine <tt/QScrollView/-Instanz erstellen und Ihr Widget als verwalteten Bereich mittels
<tt/addChild()/ setzen.

<sect1>Dialoge
<p>
Dialoge sind ein Hauptbestandteil der Benutzerinteraktion, wann immer die Anwendung das Setzen von Parametern durch den Benutzer
benötigt. Glücklicherweise stellt die KDE-Bibliothek eine Anzahl von fertigen Dialogen zur Verfügung, die zur Abfrage von
Standardparametern wie Schriftarten und Farben dienen. Wo immer diese Informationen von Benutzer benötigt werden, sollten diese
Standarddialoge verwendet werden.

Wenn diese fertigen Dialoge nicht den Anforderungen entsprechen, müssen Sie Ihren eigenen Dialog erstellen, den Sie per Vererbung aus
<tt/QWidget/ oder <tt/QDialog/ entweder direkt durch Programmierung mit Geometrieangaben  oder mittels des Dialogeditors von KDevelop
generieren.

Die KDE-Bibliotheken bieten die folgenden Dialoge:
<itemize>
<item>KColorDialog: Auswahl einer Farbe
<item>KWizard: Basisdialog-Klasse zur Erstellung von Wizzards
<item>KEdGotoLine: Go-to-Line-Dialog für Editoren
<item>KEdReplace: Suche- und Ersetze-Dialog für Editoren
<item>KEdSrch: Suchdialog für Editoren
<item>KFontDialog: Dialog zur Schriftartauswahl
<item>KIconLoaderDialog: Icon-Auswahldialog
<item>KKeyDialog: Konfigurationsdialog für Tastaturkürzel
<item>KMsgBox: Nachrichtendialog mit bis zur vier Buttons
<item>KFileDialog: (kfile) Dateidialog zum Laden oder Speichern von Dateien
<item>KSpellDlg: (kspell) Dialog zur Rechtsschreibprüfung mit ISpell
<item>DatePickerDialog: (kab) Dialog zur Datumsauswahl
</itemize>

Zusätzlich bietet die Qt-Bibliothek:
<itemize>
<item>QFileDialog
<item>QMessageBox
<item>QPrintDialog
<item>QProgressDialog
</itemize>
<footnote>Qt 2.0 bringt einen QColorDialog für die Farbauswahl und einen QFontDialog für die Schriftartauswahl </footnote>

<sect>Kontrollelemente
<p>
Kontrollelemente werden in sichtbaren Bereichen der Anwendung genutzt und können zur Erstellung eines Dialoges oder einer Ansicht
kombiniert werden. Über die Kontrollelemente, die durch die Qt-Bibliothek geboten werden, bietet KDE:
<itemize>
<item>KButton: aktiver Maximieren/Minimieren-Button
<item>KButtonBox: verwaltet Buttons
<item>KColorButton: Button der einen Farbauswahldialog anzeigt, ruft <tt/KColorDialog/ auf
<item>KIconLoaderButton: Button der einen Icon-Auswahldialog anzeigt, ruft <tt/KIconLoaderDialog/ auf
<item>KDatePicker: Datumsauswahldialog
<item>KIntegerLine: Eingabezeile, die nur Integerzahlen annimt
<item>KLedLamp: LED Lampe
<item>KLined: Eingabezeile
<item>KNewPanner: Bereichsteiler, der zwei Widgets verwaltet<footnote><tt/QSplitter/ stattdessen benutzen, da dies in KDE
2 entfernt wurde.</footnote>
<item>KPopupMenu: PopUp-Menü mit Titel 
<item>KRestrictedLine: Eingabezeile, die nur bestimme Eingaben akzeptiert
<item>KSelector: Wertauswahl
<item>KSeparator: Standard-Trenner
<item>KSlider: Schieberegler
<item>KTabCtl: Tabulator
</itemize>

<sect>Allgemeine Klassen
<p>
<sect1>Dateien und Verzeichnisse
<p>
Qt bietet bereits eine Anzahl von Klassen um mit Dateien und Verzeichnissen zu arbeiten, diese sind:

<itemize>
<item><tt/QDir/
<item><tt/QFileInfo/
<item><tt/QFile/
<item><tt/QFileDialog/
</itemize>

Eine vergleichbare und erweiterte Technik wurde mit den KDE-Bibliotheken eingeführt und ist ähnlich zu verwenden, wie die
entsprechenden Klassen von Qt, diese sind:

<itemize>
<item><tt/KDir/
<item><tt/KFileInfo/
<item><tt/KFileDialog/
<item><tt/KFilePreviewDialog/
</itemize>

Zum Laden und Speichern von Dateien benutzen Sie bitte <tt/QFile/, welche mit Streams arbeitet. Wenn Sie netzwerktransparenten 
Dateizugriff benötigen, können Sie <tt/KFile/ nutzen.

<sect1>Datenobjekte
<p>
Die Qt-Bibliothek unterstützt Datenobjekte mit Klassen, die die Verwaltung von Listen, Arrays, Streams, Strings u.Ä. erlaubt.
Konsultieren Sie hierzu bitte die Qt-Dokumemtation für weitere Informationen.

<sect1>Grafiken
<p>
Qt unterstützt eine Anzahl von Grafikformaten, welche für Zeichen- oder Bildbearbeitungsprogramme verwendet werden können. Zur
Ausgabe wird <<tt/QPainter/ verwendet.

<sect1>Prozesse
<p>
Da Anwendungen verschiedene Typen von Interprozesskommunikation mit anderen Anwendungen auf dem System nutzen können, wie die
üblichen Unix-Möglichkeiten, können Entwickler die Klasse <tt/KProcess/ verwenden, um mit anderen Anwendungen zu kommunizieren. Da
eine Anwendung unabhängig von derjenigen läuft, die sie gestartet hat, können Sie lediglich den derzeitigen Status der
Anwendung durch Aufruf von <tt/isRunning/ bekommen. Dieser Aufruf kann zudem mit verschiedenen Startwerten geschehen. Schließlich
kann der Prozess die Anwendung benachrichtigen, wenn sie beendet wurde oder sich selbst beendet hat. Siehe <tt/KProcess/ für Details.

<chapt>KDE Applikationsklassen
<p>
Die KDE-Bibliotheken, in Verbindung mit der Qt-Bibliothek, bieten Entwicklern den kompletten Rahmen zur Anwendungsentwicklung. Da KDE
auf Unix Betriebssysteme zugeschnitten ist, die das X11-System nuzen, könnte man denken, man müsse Unix und X11 beherrschen - da die
Bibliotheken dieses komplexe Grafik-Subsystem kapseln, muß man in den meißten Klassen hierüber nichts wissen. Wenn man mit Qt bereits
vertraut ist, wird KDE keine großen Unterschiede bezüglich Klassen und Widgets aufweisen.

Anfänger haben jedoch oft Probleme mit:

<itemize>
<item>Anwendungsentwicklung mit GUI-Komponenten
<item>Aufteilung von Anwendungen
<item>Erstellung von Widgets
<item>Inter-widget Kommunikation (Signals und slots)
</itemize>

Das Folgende wird Ihnen helfen zu verstehen, wo Sie im Allgemeinen Klassen, wie sie in KDE-Anwendungen benutzt werden, finden können,
einschließlich der entsprechenden Ersetzungen der Qt-Klassen, für diejenigen, die mit Qt vertraut sind und keinen Gebrauch von
KDE-Bibliotheken gemacht haben. Da sind die Anwendungsobjekte, ihr Verhalten und ihre Erstellung. Sie werden etwas erfahren über:

<itemize>
<item>die am häufigsten benötigen Objekte einer KDE-Anwendung
<item>den Unterschied zwischen Ihrem Code und der Rahmenanwendung
<item>KDE Anwendungsklassen, die die Window Manager-Kommunikation kapseln
<item>die Klasse <tt/QWidget/, von denen alle GUI-Komponenten abgeleitet sind
<item>grafische Objekte
<item>die Zwischenablage
</itemize>

Mehr Informationen über KDE-Anwendungen können in den folgenden Sektionen nachgeschlagen werden:

<list>
<item><htmlurl url="../programming/index.html" name="The KDevelop Programming Handbook">
<item><htmlurl url="../tutorial/index.html" name="KDE Application Tutorials Handbook">
</list>

Zu Informationen über Qt-Anwendungsdesign, schauen Sie bitte in die Qt-Onlinereferenz.


<sect>Die Anwendungs-Instanz
<p>

Im Allgemeinen wird eine KDE-Anwendung begonnen, indem man eine Instanz (und nur eine!) der Klasse <tt/KApplication/, die von der
<tt/kdecore/-Bibliothek bereitgestellt wird, erstellt. Die Klasse <tt/KApplication/ ist abgeleitet von der entsprechenden Qt-Klasse
<tt/QApplication/.

Was genau passiert ist, das <tt/QApplication/ die Ereigniswarteschlange der Anwendung verwaltet, das bedeutet, sie wertet Ereignisse
aus dem darunter liegenden Window-System  aus und sendet sie an ihre Kindprozesse, wie z.B. Maus-Bewegungen oder Tastaturereignisse.
Dies ist auch der Grund, warum nur eine Instanz von <tt/KApplication/ verwendet werden darf und warum dies das Erste ist, was die
<tt/main()/-Funktion ausführt.

Die <tt/KApplication/-Klasse erweitert die Qt-Klasse mit zusätzlichen Funktionen für eine Anwendung mit einem gleichartigem Aussehen,
die sich in andere Desktop-Komponenten integriert und die daher in ihrem Verhalten von Steuerungsanwendungen (in KDE im Allgemeinen
Bestandteil des KDE Kontrollzentrums) beeinflusst werden kann, wie z.B. Tastaturkürzelkonfiguration und GUI-Stil.

Wie in der Qt-Klasse, so bietet die <tt/KApplication/-Klasse eine statische Funktion um auf das Anwendungsobjekt innerhalb
der Anwendung zugreifen zu können, <tt/KApplication::getKApplication()/. Diese Vorgehensweise löst das Problem, den Zeiger an das
Anwendungsobject weitergeben zu müssen. Außerdem stellt die Include-Datei <tt/kapp.h/ ein Makro zur Verfügung, welches anstelle der
statischen Funktion benutzt werden kann, <tt/kapp/. Immer wenn Sie auf das Anwendungsobjekt zugreifen müssen, benutzen Sie bitte
dieses Makro.<footnote>In KDE2 kann man das Anwendungsobjekt mit mit <tt/KApplication::kApplication()/ erhalten.</footnote>

Das <tt/KApplication/-Object selbst bietet eine Anzahl von Instanzen, wie sie gewöhnlich in KDE-Anwendungen verwendet werden und
bietet dem Programmierer hierauf Zugriff durch Funktionen. Sie werden intensiven Gebrauch hiervon machen, da hierdurch die Erstellung
eigener Instanzen umgangen wird. Diese Objekte werden für folgende Zwecke verwendet:

<descrip>
<tag/<bf/KConfig//, ein Konfigurations-Objekt, welches zum Lesen und Schreiben von Konfigurationsinformationen in einer
Ressource-Datei verwendet wird. Benutzen Sie bitte die zugehörigen Methoden von <tt/KConfigBase/ um Werte zu lesen und zu schreiben.
Das Konfigurationsobjekt erhalten Sie durch <tt/kapp->getConfig()/<footnote>In KDE2 benutzen Sie bitte <tt/KGlobal::config()/ um das
Konfigurationsobjekt zu erhalten</footnote>, die Session Management Konfiguration durch <tt/kapp->getSessionConfig()/ <p>

<tag/<bf/KIconLoader//, ein Objekt welches Icons in <tt/QPixmap/s unter Benutzung des KDE-Dateisystems lädt. Hierdurch wird
verhindert, daß nach einer Bilddatei im Dateisystem gesucht werden muß, denn es muß nur der Dateiname angegeben werden. Benutzen Sie
das Makro <tt/Icon("icon.xpm")/ um ein Icon auf einfache Art und Weise zu laden. Die Iconloader-Instanz kann mittels
<tt/kapp->getIconLoader()/ erhalten werden<footnote>KDE 2 nutzt <tt/KGlobal::iconLoader()/ um auf die Iconloader-Instanz
zuzugreifen</footnote> <p>
<tag/<bf/KLocale// ein Objekt, welches die aktuellen Spracheinstellungen zurück gibt. Das sorgt dafür, daß die Anwendung in der
Sprache auf dem Desktop dargestellt werden, die der Benutzer global eingestellt hat. Benutzen Sie das Makro <tt/klocale/ um auf das
locale-Objekt zuzugreifen.Auf die  klocale-Intanz kann durch <tt/kapp->getLocale()/ zugegriffen werden (wie es das Makro klocale
bereits tut)<footnote>Auch dies wird in KDE2 durch eine statische Methode <tt/KGlobal::locale()/ersetzt.</footnote> <p>

<tag/<bf/KCharsets// das Zeichensatzobjekt, z.Zt. global durch den Benutzer eingestellt. Hierdurch werden Tastaturereignisse in den
korrekten Zeichensatz übersetzt. Die Zeichensatzinstant kann mit <tt/kapp->getCharsets()/ ermittelt werden.<footnote>In KDE2 ersetzt
durch <tt/KGlobal::charsets()/.</footnote></descrip><p>

Zusätzlich bietet Ihnen die KApplication-Klasse alle benötigten Methoden um auf Dateien gemäß dem KDE-Filesystemstandard zuzugreifen.
Dies verhindert Probleme die durch festes Einprogrammieren von Pfaden entstehen können (siehe <htmlurl
url="../programming/index.html" name="Das KDevelop Programmierhandbuch"> für weitere Informationen zum KDE-FSS).
Die Klasse stellt außerdem benötigte Zugrifssmechanismen für Anwendungs-Icons und Mini-Icons, aktuelle KDE-Schriften und
Unterstützung zum Sitzungsmanagement.

Um die Zwischenablage zu nutzen, bietet die <tt/QApplication/-Klasse ein Zwischenablagenobjekt, <tt/QApplication::clipboard()/,
welches für den Austausch von Text und Bilddaten zwischen Anwendungen genutzt werden kann (siehe <tt/QClipboard/).

Internationalisierung ist ein weiterer Schlüsselbegriff für KDE-Anwendungen. Diese wird mit dem <tt/KLocale/-Objekt wie bereits
erwähnt unterstützt und wird durch das Makro <tt/i18n()/ aus <tt/kapp.h/ schon verwendet.

Dies ist eine Abkürzung für den Aufruf des KApplication-Zeigers auf den KLocale-Zeiger und wird von gettext ausgelesen um alle durch
das Makro eingeschlossenen Zeichenketten in eine Anwendungsspezifische Nachrichtendatei zu schreiben, welches dann übersetzt werden
kann.

Schlußendlich erzeugt <tt/KApplication/ ein Hilfe-Menü, welches in eine Menüleiste eingefügt werden kann, einen vordefinierten (an-
und ausschaltbaren) Hinweisdialog und den "Über"-Dialog Ihrer Anwendung.

Die folgenden Ratschläge sollten im Umgang mit der <tt/KApplication/-Klasse beherzigt werden:

<itemize>
<item>erzeugen Sie das <tt/KApplication/-Objekt am Anfang der <tt/main()/-Funktion
<item>führen Sie die Anwendung mit <tt/exec()/ am Ende der <tt/main()/-Funktion aus
<item>beenden Sie die Anwendung durch Aufruf der <tt/quit()/ Slot-Funktion.
</itemize>

Bei Verwendung von <tt/KApplication/ können Sie die folgenden Ereignis-Signale auswerten:

<itemize>
<item>kdisplayPaletteChanged()
<item>kdisplayStyleChanged()
<item>kdisplayFontChanged()
<item>appearanceChanged()
<item>saveYourself()
<item>shutDown()
</itemize>

Da die Widgets Ihrer Anwendung diese Signale empfangen, aktualisieren sie sich normalerweise selbst. Die wichtigsten Signale für Sie
sind in den meissten Fällen <tt/saveYourself()/ und <tt/shutDown()/ (wobei <tt/KTMainWindow/ bereits <tt/saveYourself()/ abfängt und
<tt/KTMainWindow::saveData()/ aufruft).

Sie werden mittels der entsprechenden, statischen Methoden von <tt/kwm.h/ in der Lage sein, mit dem KWM Fenstermanager zu
kommunizieren.

<sect>Auswertung der Kommandozeilenargumente
<p>

Eine Anwendung soll normalerweise in der Lage sein, Kommandozeilenargumente auszuwerten. Diese werden durch den Benutzer angegeben,
entweder beim Start von der Kommandozeile aus oder innerhalb einer kdelnk-Datei. Kommandozeilenargumente werden oft verwendet 
um die Anwendung mit einer bestimmten Datei zu starten. Dies erlaubt auch Datei-Managern Ihre Anwendung korrekt aufzurufen und
die Mime-Typ-Mechanismen in KDE zu verwenden. Um Kommandozeilenargumente verwenden zu können, sollte die <tt/main()/-Funktion mit der
folgenden Deklaration konstruiert werden:

<tscreen><verb>
int main(int argc(), const char* argv[])
</verb></tscreen>

Hierbei enthält <tt/argc()/  die Anzahl der übergebenen Optionen und das Array <tt/argv[]/ die Optionen in Textform. 
Wie auch der Konstruktor von <tt/QApplication/, wird auch derjenige von <tt/KApplication/ zuerst ausgeführt. Er wertet alle Optionen
aus, die ihn betreffen (z.B. Geometrie- oder Display-Optionen) und entfernt diese aus dem Array, so daß sie nicht mehr ausgelesen
werden können, wenn die <tt/KApplication/-Instanz deklariert ist:

(aus der  Qt 1.42 Online-Referenz zu <tt/QApplication/)
<itemize>
<item><bf/-nograb/, weist Qt an weder Maus noch Tastatur auszuwerten. (Wenn Sie Ihr Programm in einem Debugger, ist diese Option
automatisch aktiviert).
<item><bf/-sync/ (nur unter X11), schaltet den synchronen Modus für Debug-Zwecke ein.
<item><bf/-display/ Anzeige, setzt das zu verwendende X-Display (standard ist $DISPLAY).
<item><bf/-geometry/ Geometrie, setzt die Abmessungen des Hauptfensters.
<item><bf/-fn/ oder -font Schriftart, definiert die  Anwendungsschriftart.
<item><bf/-bg/ oder -background color, setzt die standard Hintergrundfarbe und die Anwendungspalette (Hell- und Dunkelschattierungen
werden berechnet). 
<item><bf/-fg/ oder -foreground color, setzt die standard Vordergrundfarbe.
<item><bf/-name/ name, setzt den Anwendungsnamen.
<item><bf/-title/ title, setzt den Anwendungstitel (caption).
<item><bf/-style=/ style, setzt den  GUI-Stil der Anwendung. Mögliche Werte sind Motif und Windows. Standardmäßig wird die globale
Einstellung von KDE gewählt.
<item><bf/-visual/ TrueColor, zwingt die Anwendunng, TrueColor auf einem 8-bit Display zu verwenden.
<item><bf/-ncols/ count, limitiert die Anzahl an Farben im Farbraum auf einem 8-Bit-Display, wenn die Anwendung die
QApplication::ManyColor Spezifikation benutzt. Wenn count = 216 ist, wird ein 6x6x6-Farbraum benutzt (z.B. 6 Rot-Werte, 6 Grün-Werte
und 6 Blau-Werte); bei 108 wird ein 3x3x3 und für andere Werte ein Farbraum, der proportional zu einem 2x3x1-Farbraum ist, benutzt.
<item><bf/-cmap/ läßt die Anwendung eine eigene Farbtabelle auf einem 8-Bit-Display verwenden.</itemize>

Anschließend wertet <tt/KApplication/ Optionen aus, deren Werte innerhalb einer <tt/.kdelnk/-Datei gesetzt werden können.
Üblicherweise enthalten diese Link-Dateien internationalisierte Beschreibungen und den Anwendungsnamen, wie auch andere Werte wie den
Namen des Icons und des Mini-Icons. Die Kommandozeilenargumente um diese Werte zu benutzen lautet:

 <tscreen><verb>
foo %i %m -caption \"%c\"
</verb></tscreen>

Hierdurch wird die Anwendung mit der Option -icon irgendwas.xpm für %i und -miniicon for %m gestartet. Der Anwendungstitel kann mit
-caption %c gesetzt werden. Die Klasse <tt/KApplication/ bietet zudem entsprechende Methoden die Rückgabewerte zu den Kommandozeilen
argumenten zurückgeben.

Wenn Sie die Kommandozeilenargumente selbst auswerten möchten, können Sie dies direkt nach der Deklaration des
Anwendungsobjektes tun um die o.g. Werte in der <tt/main()/-Funktion auszuschließen. In der Anwendung selbst (z.B. der
Hauptfensterklasse), stellt <tt/QApplication/ die Methoden <tt/argc()/ und <tt/argv()/  um beliebige andere Optionen auszuwerten.
Auf diese kann über die Argumentnummer zugegriffen werden, wobei das Argument <tt/kapp->argv()[0]/ der Anwendungsname ist; Auf alle
folgenden Argumente kann man über <tt/kapp->argv()[nummer]/ zugreifen.<footnote>KDE 2 enthält eine zusätzliche Klasse,
<tt/KCmdLineArgs/, um zusätzliche Kommandozeilenargumente zu verarbeiten, die bereits von KDevelop für KDE 2 Projekte verwendet
wird.</footnote>

<comment>Die <tt/KApplication/-Klasse verwendet verschiedene Methoden um den Anwendungsstil, -schriften und -farben durch X11 Atome,
welche alle offenen Anwendungen auffordern, ihre Einstellungen rekursiv über alle Widgets zu ändern. Dies wird automatisch
durchgeführt, wenn der Benutzer die entsprechenden Werte mittels des KDE-Kontrollzentrums ändert, was eines dieser X11-Events
hervorruft. Die Methode <tt/x11eventFilter()/ entsendet die entsprechenden Signale um diese Werte zu ändern. So weit mir bekannt ist,
ist der einzige Wert, der in KDE 1.x nicht verändert wird, das Doppelklick-Intervall, welches in <tt/QApplication/ standardmäßig
auf 400ms eingestellt ist. Veränderungen hieran ist nur durch Nutzung der Methode
<tt/QApplication::setDoubleClickInterval()/.</comment>

<sect>Andere Anwendungsklassen
<p>
Durch "Andere Anwendungsklassen" wollen wie alle Ersetzungen der <tt/KApplication/-Klasse beschreiben. Die KDE-Bibliothek <tt/kdeui/
enthält zwei weitere Klassen, die von <tt/KApplication/ für spezifischere Anwendungen innerhalb von KDE-Anwendungen  abgeleitet
sind. Dies sind die Klassen <tt/KControlApplication/ und tt/KWMModuleApplication/.

<sect1>KControlApplication
<p>
<tt/KControlApplication/ ist eine Klasse für spezielle Anwendungen, die als Setup-Module geplant sind. Da sie einen Tab-Dialog zur
Verfügung stellt, können Kontrollmodule leicht erzeugt werden. Die Unterschiede zu <tt/KApplication/ sind:

<itemize>
<item>nutzt <tt/-init/ als Kommandozeilenargument um die Methode <tt/init()/ aufzurufen. Diese ist überschrieben worden um die
Dialogeinstellungen zu initialisieren.
<item>Der Titel des Dialogs muß unabhängig von der Art, wie in <tt/KApplication/ verfahren wird, mittels <tt/setTitle()/ gesetzt
werden.
<item>bietet einen kompletten Rahmen für Ihre Kontroll-Widgets, welche eingefügt werden müssen.
</itemize>

Um die virtuellen Methoden wie <tt/init()/ zu überschreiben, müssen sie eine anwendungsspezifische <tt/KControlApplication/-Klasse
von <tt/KControlApplication/ ableiten. Die Klasse wird allgemein für Kontroll- (Setup-) Anwendungen wie in KDE als auch in separaten
Programmen verwendet.

<sect1>KWMModuleApplication
<p>
KWMModuleApplication ist eine weitere Klasse, die von <tt/KApplication/ für bestimmte Zwecke abgeleitet ist: die Klasse bietet
Methoden, die eine Interaktion mit dem Fenstermanager erlauben. Ein Beispiel für eine KWMModuleApplication ist der <tt/kpager/,
welcher Signale des Fenstermanagers zur Verwaltung der Fenster mittels statischen Methoden des KWM benutzt.

Um eine KWMModuleApplication zu erstellen, müssen Sie zunächst Ihre Anwendungsinstanz erzeugen und die Methode <tt/connectToKWM()/
aufrufen.

<sect1>Docken von Fenstern
<p>
Ein weiteres Thema beim Design von KDE-Anwendungen ist die Nutzung von <tt/kpanel/ um ihre laufenden Anwendungen symbolisiert
darzustellen. KDE-Benutzer sind wahrscheinlich vertraut mit der Anzeige der Anzeigeeigenschaften links von der Uhr im <tt/kpanel/.

Der Weg hierzu ist recht einfach: Sie müssen ein Widget zur Verfügung stellen, das im Panel gedockt ist; hierzu muß ein Hauptfenster
erzeuugt werden, indem der Konstruktor mit 0 als Elternfenster aufgerufen wird. Binden Sie die kwm.h Headerdatei ein und rufen Sie  

<tscreen><verb>
KWM::setDockWindow(mywidget->winID());
</verb></tscreen>
auf.

Bedenken Sie, daß es für das Verstecken des Widgets nicht genügt, <tt/destroy()/ aufzurufen (siehe <tt/QWidget/ für <tt/destroy()/
und <tt/create()/).

<sect>Das Hauptfenster
<p>
Wie bereits erwähnt, ist das zuerst zu erstellende Objekt einer KDE-Anwendung eine Instanz von <tt/KApplication/. Es bietet
sicherlich keine Widgets (sichtbare Benutzerschnittstellen), außer dem "Über"-Dialog wie in der <tt/QApplication/-Klasse als
PopUp-Menü, das jedoch nicht sichtbar ist. Daher benötigt jede Anwendung ein Top-Widget, um sich selbst sichtbar zu machen.

Betreffend die sichtbaren Teile, ist der Programmierer frei in der Wahl des Widgets das er Benutzen oder von dem er sein Hauptfenster
ableiten möchte. Es kann ein simples <tt/QLabel/ genauso wie das komplexe <tt/KTMainWindow/ sein, welches alle benötigten Objekte
einer gewöhnlichen Desktop-Anwendung enthält.

<sect1>Allgemeine Regeln
<p>
Im Allgemeinen werden Sie fertige Komponenten benutzen wollen, die spezialisiert sind. KDE unterstützt dies mit der Klasse
<tt/KTMainWindow/ als ein Pendant zur Qt-Klasse <tt/QMainWindow/. Bevor wir die allgemeine Regel betrachten, zunächst ein Blick auf
die Ausname: die Benutzung jedes anderen Widgets.
Wenn sie <tt/QApplication/ als Basisklasse Ihrer Anwendung verwenden wollten, würden Sie die Anwendungsinstanz erstellen, danach das
Hauptwidget. Jetzt ist es sicher, das Widget als Top-Widget mittels <tt/setMainWidget()/ zu registrieren da der Benutzer dann den
"Schließen"-Button des Hauptfenster zum Verlassen verwenden kann. Er erwartet, daß die Anwendung beendet wird, wenn das letzte
Fenster geschlossen wird. Um dies jedoch zu erreichen, müssen Sie den QApplication-Slot <tt/quit()/ aufrufen
Sie könnten dies in einer abgeleiteten Klasse durch überschreiben der Methode <tt/QWidget::closeEvent()/ tun aber mit der Methode
<tt/setMainWidget()/ wird dies bereits getan.  In jedem Fall, in welchem <tt/KApplication/ genutzt wird, sieht es ähnlich aus, mit
dem Unterschied, daß die entsprechende Methode von KDE <tt/setTopWidget()/ ist. Die einzige Ausnahme besteht bei Benutzung der Klasse
<tt/KTMainWindow/, welche dies automatisch in ihrem Konstruktor erledigt (wenn kein anderes Top-Widget vorhanden ist).

Ein weiterer Weg wäre, kein Fenster explizit als Top-Widget zu setzen, wenn Sie mehrere Top-Widgets verwenden.  Da das
Anwendungsobjekt noch immer mit <tt/quit()/ beendet wird, Sie können stattdessen <tt/connect()/ nutzen um es automatisch aufzurufen,
wenn das letzte Anwendungsfenster geschlossen wird (<tt/QApplications/ <tt/lastWindowClosed()/-Signal nutzend):

<verb>
QObject::connect(kapp, SIGNAL(lastWindowClosed()), kapp, SLOT(quit()));
</verb>

<sect1>Benutzung von KTMainWindow
<p>
Gewöhnlich besitzen Desktop-Anwendungen ein komplettes Benutzerinterface, welches üblichen Regeln für GUI-Programme folgt. KDE bietet
eine Klasse, welche bereits  alle benötigten Funktionen enthält, aus denen eine Anwendung Nutzen ziehen kann, <tt/KTMainWindow/,
welche Teil der <tt/kdeui/-Bibliothek ist. Sie ist eng verbunden mit <tt/KApplication/ und daher sehr einfach zu benutzen. Die
Klasse bietet:

<itemize>
<item>Unterstützung des Sitzungsmanagements
<item>ein Hauptwidget
<item>eine Menüleiste
<item>so viele Werkzeugleisten wie ihre Anwendung benötigt
<item>eine Statuszeile
</itemize>

Die Elemente des Widgets selbst werden bereits von <tt/KTMainWindows/ Geometrie-Implementation verwaltet, daher müssen Sie sich
normalerweise nicht darum kümmern müssen, eine Anwendungsspezifische Instanz für Ihr Programm neu zu implementieren.

<chapt>Event Handling
<p>
This chapter will illuminate some of the internals of KDE/Qt programming, and will dive into the fascinating subject of event handling as well. It is meant for people who feel they need deeper insight to the more advanced topics of Qt based programming. In particular the Signals and Slots mechanism is explained in detail. This because users have indicated that resources
about the meaning and usage of signals and slots are somehow hard to find in other 
documentation. For non-english persons the translated version are available, offering easier access 
 than the originals.

Event handling covers the communication of an application. Withn that, we mean the interaction between different objects and between objects
and the user. Beginners in particular have a hard time to learn the mechanisms underlying event handling. Many of the misconstructions found in beginners' code can be attributed to a lack of understanding of the Qt signals and slots framework. 

Signals and slots are formally not a part of event handling but are used during the
event processing often and are a major reason why simple widget elements such as buttons 
can be usd in such a simple way.


<sect>Signals and Slots
<p>
This section covers the Qt concept of advanced object communication. 
In this context objects are the instances of classes that are
created during runtime by the application. The instances normally don't know about each other, but they have to communicate to allow
method calls of other object's methods. The usual way for XWindow has been using function pointers, but this lead to very complex code. It also gives no opportunity for the compiler to check types (a function pointer is actually just a (void*) pointer).

The Qt library offers a far better solution to this by a mechanism that is called signals and slots.

Before going into the technical details, I'll explain the mechanism by a comparison to everyday-life. Imagine you have a bunch of
people somewhere and someone looks into the sky. He sees a balloon and points with his finger to the balloon and says: "Hey, there's a
balloon !". Now, what do other people do that are standing around him ?  One who is interested in balloons will look up as well and
have a look at it, maybe take a picture with a camera. Others won't because they were never interested in balloons and don't want to
know about it; they just ignore what was said.

With Signals and Slots, things are just the same, except that instead of people objects interact. Objects are instances of classes that can
send out a signal in a certain situation. Objects which are interested in that kind of signal react to it, others do not. While humans have
the choice to react interactively, class objects can't because they have no ears. But they can provide a kind of ears that listen to
signals that were sent out. Then, those special kind of ears have to be connected to the signal an object emits to provide the medium
to transmit the message to the receiver. Any kind of ears that could react won't if they are not connected with the signal and
therefore ignore the message transmission.

I hope this made somehow clear how the signal/slot mechanism works generally. The chart shows this a bit more appropriate:

<code>
Person_1                            Person_2                       Person_3

signal balloon_seen();              slot i_see_it();               slot not_interested();

watch_out(){                        i_see_it(){				
  if(balloon){                         look_where();
    emit balloon_seen();            }
  }
}

connect (Person_1, SIGNAL(balloon_seen()), Person_2, SLOT(i_see_it()));
</code>

This explains more about the functionality. The class that builds Person_1 provides a signal balloon_seen(). Also it has a
method watch_out() that symbolizes that he watches for something. If this method detects that a balloon is there, it emits the signal
and transmits the message to the outside of its responsibility. After the emit, Person_1 is not responsible for any actions that
follow as a reaction to this signal; it just does the message invocation.

Now, the table contains the other persons Person_2 and Person_3. Both provide methods that are slots; Person_2 has one slot that is
called i_see_it() and Person_3 a slot not_interested().  Those slots are just like any method with the difference that they can also be
connected to a signal and build a receiver for the connection. They will execute the slot implementation when the object
receives the signal message. In this case, we have a typical connection method at the last line. The connect() takes Person_1 as a
signaler object. It connects the signal balloon_seen() that the object may send out when he sees a balloon with Person_2. Person_2 is
then the receiver object. Now, the receiver has to do something with the signal; we have to tell him, which method to execute whenever
Person_1 sees a balloon. The implementation of the slot i_see_it() just calls another method to make this example short. look_where can
symbolize a method to localize the coordinates, the color, the size of the balloon or how many people the balloon carries.

Person_3 then is anther object. The class that builds it provides a slot as well, the method not_interested().  The implementation
doesn't matter for our example here, because we don't want Person_3 to react to Person_1's detection of a balloon. We could, if we add
another connect though, just with Person_3 instead of Person_2 and the according slot Person_3's class provides.


<sect1>Requirements
<p>
This way of object communication is not provided by C++; it is a part of the Qt library.

If you want to use Signals and
slots they have to be declared as such in the class-declaration for two good reasons:

<enum>
<item>you know which signals and slots a class provides and the parameters they need
<item>the moc (Meta Object Compiler) of Qt can create the implementation for signals and slots automatically and include it to the compile process (since signals and slots are not part of the C++ standard, your C++ compiler wont do that)
</enum>

Now, we're going into the details of the Qt library. To make use of the signal/slot mechanism, you <bf/have/ to:

<itemize>
<item>inherit from <tt/QObject/ or any subclass of <tt/QObject/
<item>add the macro Q_OBJECT at the beginning of the class-declaration (<bf/without a semicolon !/)
<item>run <bf/moc/ over the header file to produce an implementation file to be compiled
</itemize>

Normally, KDE and Qt applications constructed with automake and autoconf (amongst them all programs made with KDevelop) already run moc when necessary. This is done by
the program <tt/automoc/, which also does everything needed to create the meta object implementation for signals and slots as well as
incorporating the correct headers for the implementation and the inclusion into the build-process. So you don't have to take care of
updating any moc output files after changing header file implementations nor about the integration of the moc source file output into
the project. Those will be automatically generated by detection of the Q_OBJECT macro in the class declaration.

If you have further questions please read the page "Using The Meta Object Compiler" of you Qt Online Reference. It covers all restrictions
on using signals and slots.


<sect1>Emitting Signals
<p>
This part describes the several ways of signal emission. It is important to know where signals are emitted and for what
purpose you would do so.

We separate two ways of signal usage, one which is the usual way through sub-classing <tt/QObject/, and the other to use the
<tt/QSignal/ class from within classes that don't want to inherit from <tt/QObject/ but want to use the signal emission features.

So, when deriving from <tt/QObject/, we already said that we have to add the <tt/Q_OBJECT/ macro into the class declaration. Then any
signal that a class object will emit has to be inserted in the class declaration with the modifier <tt/signals:/

Example:
<code>
class Foo : public QObject{
  Q_OBJECT

public:
  Foo();

signals:
  void mySignal();
  void myParameterSignal(int, int);
};
</code>
This shows the insertion into the class declaration and also shows that you can use signals to emit values as well. This is one of the best features and is widely used throughout KDE and Qt.

Now, this shows one half of the work. The other is: where does the signal get emitted ? For this, you have to use the keyword
<tt/emit/ in connection with the signal name and the transmitted actual parameters. The place where to emit is usually within a method
that is processed and wants to inform about the state of the object by the signal to outside objects.
<comment>The keyword <tt/emit/ is technically only an empty #define, therefore the C++ -compiler only sees a normal method call. The
<tt/moc/ takes care to add the according meta-object creation and initialization, which finally implements the signal as a member
function in the moc output.</comment>

As an example, we have a look at a snippet of code where a method of <tt/KMyClass/ cuts out a part of a visible area
the user works with:

<code>
void KMyClass::cut(){

  int xpos=view->xPos();
  int ypos=view->yPos();
  view->cut(xpos, ypos);

  emit cutting(xpos, ypos);
}
</code>

This method could be called e.g. from a toolbar icon "Cut" or the according menu entry of the application's menu bar. We assume that we
have a view area that we retrieve as a pointer <tt/view/. The class providing the view area offers cutting a selection by an x and y
integer value. The actual values can be found out with <tt/xPos()/ and <tt/yPos()/ and stored into xpos and ypos to avoid temporaries
and to reuse the values for emitting the signal. Then, we call the cutting method via the view object by the actual parameters.
Finally, we want to inform about what's being done by emitting a signal <tt/cutting()/. In case anyone needs to know about what
happened, we have also included the exact information about where we have done the action by transmitting the values with the signal.


Another way to produce a signal is, as mentioned, possible without sub-classing <tt/QObject/. Qt provides this by the class
<tt/QSignal/.  The usage is rather simple, though inheritance of <tt/QObject/ should always be preferred.

To use <tt/QSignal/, write a normal C++ class. Then add the following:

<enum>
<item>#include &lt;qsignal.h&gt;
<item>add a <tt/QSignal/ member attribute to the class declaration
<item>add a method <tt/void connect(QObject* receiver, const char* member);/ to the class
<item>create the signal in the constructor with <bf/new/
<item>destroy the signal in the destructor with <bf/delete/
<item>implement the <tt/connect()/ method by calling <tt/connect(receiver, member)/ on the signal to emit
<item>emit the signal at any place in your class code with <tt/yoursignal->activate()/
</enum>


<sect1>Slot Implementation
<p>
After explaining the ways of how to produce signals by objects, those can only be of important use if an application's classes provide
slots that get connected with signals. The slots themselves are normal C++ class member functions and can therefore be called any place any
time you need to, only depending on the class access rights. They just have an additional feature that they can be called automatically
during runtime by their connected signals. The main difference is the declaration of the methods within the class:

<code>
class Foo : public QObject{
  Q_OBJECT

public:
  Foo();

public slots:
  void mySlot();
  void myParameterSlot(int, int);
};
</code>

Above, you see that the class <tt/Foo/ has two slots declared in the class-declaration. As the modifier is also preset, here to public,
it follows that you can also restrict slot usage by access rights to public, protected and private. The only thing to watch out for
is that all methods after <tt/public slots:/ are slots, so you have to start with <tt/public:/ again, if you want to add public methods
behind the slots declarations. Whe connecting signals to slots, the sender can only connect to slots the receiver allows to call
depending on the access rights e.g. a private slot cannot be called by an instance of another class than the own (which means only
instances of the same class can connect signals to this slot).

Another restriction is the return type. As slots are most often called by signals, where should they deliver any return values ?
Therefore, your slots will always have <tt/void/ as return type.<footnote>For all restrictions of implementing slots in classes, see
the Qt online reference documentation, section <em/The Meta Object Compiler/.</footnote>

<sect1>Connections
<p>
The last section of this chapter deals with connecting signals and slots. As stated in the Signals section, there are two ways to
produce signals, and in the Slots section we saw that slots are methods which have modifiers as well.

When it comes to connecting signals and slots, you generally will use the static method of <tt/QObject/ to send a signal to a method:

<tscreen><verb>
bool connect(const QObject* sender, const char* signal,
             const QObject* receiver, const char* member)
bool disconnect(const QObject* sender, const char* signal,
             const QObject * receiver, const char* member)
</verb></tscreen>

Both are static public members of <tt/QObject/ and can be called everywhere in the code if you want to connect/disconnect a sender and
receiver by certain signals and slots. The signal in these methods have to be used with the <tt/SIGNAL()/ macro; the slot of the
receiver has to be used with the macro <tt/SLOT()/.

<comment>Note: within classes that inherit <tt/QObject/ you don't have to use the static variant, so instead of using
<tt/QObject::connect()/, you can also use the overloaded methods that either the sender provides (such as <tt/QMenuData/ to connect
<tt/activated()/ directly to the receiver's slot while inserting a menu entry) or just call <tt/connect()/ directly.
</comment>

Further, the signal and slot should have the same parameter list as parameters are translated from the signal to the slot method. Slot
implementations that don't require using any transmitted parameter only have to declare the type but do not need a formal parameter.
This avoids the unused parameter warnings you usually get when declaring formal parameters which aren't processed in the method. The
slot methods itself can also have less parameters than the signal emits.

Also, signals can be forwarded. This means, you can use the <tt/connect()/ method to connect two signals, meaning that the sender's
signal will cause the receiver to emit the connected signal.
If several slots are connected to one signal, the slots will be ececuted one after the other, in an arbitrary order, when the signal is emitted. (Qt documentation: metaobjects.html)

<sect>The Event Queue
<p>
The previous chapter dealt with the object communication by Qt's signal/slot mechanism and we know how an application can arrange
a certain functionality. 
But we have not yet discussed the events produced by the user. Generally, he communicates with an
application by the keyboard and the mouse. When running an application under XWindow, the X11 protocol ensures that the right
application is called to process the events. Only the application object receives the event and can provide means to
handle them. This is called event handling. The application object therefore has to keep an event queue when initialized where events
run into and get processed to the right application window. The application itself is running in a so-called <tt/main event loop/,
which indicates that it waits for user interaction until the user quits the application either via the <tt/quit()/ slot or by calling
<tt/exit()/. The <tt/exit()/ function also returns the value to the main() function's call of <tt/exec()/ to terminate. If the number
<tt/exit()/ is called with is higher than 0, an error has occurred. The <tt/exec()/ function call in <tt/main()/ starts the event handling.

X11 event handling starts by defining the events the window is willing to process. All other
events are already filtered out. The events which are selected, go into the event queue and
wait to be processed. Typical events include the XExposeEvent, XDestroyWindowEvent and XResizeRequestEvent. All these events have to be handled by the application. Fortunately (for you) Qt takes care of most of the event processing. This is done using the <tt/QEvent/ class; the Qt event abstraction.

This QEvent is then processed by <tt/QApplication/'s <tt/notify()/ function. This sends all receivers which are derived from
<tt/QObject/ and are part of the application the according event with <tt/receiver->event(QEvent* event)/. The application objects
therefore get notified about any event that happened and can process the event via the re-implemented <tt/event()/ method of
<tt/QObject/ if needed. <tt/QObject/ also allows a self-created event filter functionality by installing an event filter on the
class. The event filter is processed first if one is installed and then the event method returns control over the event if the event
filter returned false. If the <tt/event()/ method doesn't find any event processing, it returns <em/false/ and the application gets to
know that the object didn't sign responsible for the event. If the event was successfully processed and the <tt/event()/ returns
<em/true/, the event is deleted from the event queue.

<sect1>Processing Events
<p>
Qt and KDE applications use a graphical interface to make themselves visible to the user. Application windows are deived from <tt/QWidget/, the baseclass for any graphical object drawn in windows. Independent of how the widget
is created, the application object notices all widgets that are created and keeps a list of these. Furthermore, the windows can have
several states dependent on how they are created.

The <tt/QWidget/ class is most important to understand because it re-implements the <tt/event()/ method already to transform the
incoming event to some commonly occurring events, e.g. a mouse event, and creates appropriate filter event functions which are easier
to re-implement for the special purpose a widget may need. This is e.g. used for any widget that inherits the <tt/QWidget/ class,
because those events can be used to send out signals that are avoiding any sub-classing of common widgets such as pushbuttons. The
<tt/pressed()/ signal e.g. is emitted on the re-implementation of <tt/QWidget/'s <tt/mousePressEvent()/, showing that you don't have to
subclass a simple pushbutton to find out the event and to get notified that the user pressed it.

Re-implementing these methods is one of the common tasks of a programmer writing his own widgets, therefore you will have to know about
the virtual event functions of <tt/QWidget/ and the event queue processing very well.

Above, we mentioned that a widget can have several states. This predefines the behavior of the widget towards the user as well as
towards the application object.

A widget can be:

<enum>
<item>a <bf/main widget/ when set as the main widget with <tt/QApplication/'s <tt/setMainWidget()/ or <tt/KApplication/'s
<tt/setTopWidget/.
<item>a <bf/top widget/ when the parent of the widget is 0.
<item>a <bf/modal widget/ usually a <tt/QDialog/ which has its own event loop
<item>a <bf/semimodal widget/ like a <tt/QDialog/, but without its own event loop
<item>a <bf/popup widget/ when the widget flag is set to WType_Popup, is also a top widget
</enum>

The specialized behavior of the widgets depending on their creation is then:
<enum>
<item><bf/main widget:/ a main widget is the most important widget of the application, but the application doesn't need to have a main
widget of course. If it has, and the main widget gets closed, the application terminates automatically by calling <tt/quit()/.
The <tt/QApplication/ method <tt/mainWidget()/ returns the pointer to the main widget.

<item><bf/top widget:/ a top widget is a widget which has no parent. All widgets that have non-zero parents are
sub-widgets of the parent. The list of top level widgets can be found with <tt/QApplication::topLevelWidgets()/. If an application
doesn't have a main widget but only top widgets, connect <tt/quit()/ to <tt/QApplication::lastWindowClosed()/ to terminate the
application, otherwise the application object will still exist even if all windows are closed. The application finds the currently
active (focus enabled) widget with <tt/QApplication::focusWidget()/.

<item><bf/modal widget:/ a modal widget is a widget derived from <tt/QDialog/. <tt/QDialog/ widgets have their own local event loop
which is entered when calling <tt/exec()/ on the dialog object. The dialog is modal, if the third widget flag is set to <em/true/,
meaning that the dialog has to be terminated before the event processing can return to other application windows. All events are sent
to the dialog by the application object. The current modal widget is found by the application by
<tt/QApplication::activeModalWidget()/.

<item><bf/semimodal widget:/ is a widget that disables events to other widgets like a modal dialog but does not have its own event
loop. The modal flag has to be set to <em/true/ like for a <tt/QDialog/, although the semimodal dialog is derived from <tt/QWidget/.

<item><bf/popup widget:/ a popup widget is a popup that, when it appears, makes the application object send all events to it. The popup
has to be finished before the event returns to any other widget, except for another popup. The current popup widget is found by the
application object by <tt/QApplication::activePopupWidget()/ to post the events to.
</enum>

The application object itself keeps track of all widgets that it is responsible for. The list of widgets can be retrieved by
<tt/QApplication::allWidgets()/.

<bf/Summary:/ The application object is responsible for retrieving the events that were invoked by the user from the underlying window
system. Then it converts these events via <tt/QEvent/ and can sent the event to any widget that is currently active. The widget itself
is responsible to process the event either by accepting the event after finding out that it has an event-handler (or to be precise: the
event handler has to return true to the notifying of the application's event posting). The event is deleted from the queue if an event
handler was found, if all possible event handlers return false, the application is not responsible for the event and the event is
ignored (deleted from the queue as well).

What is left to explain about event processing is the installation of own event filters for widgets or any other object derived from
<tt/QObject/ and the way <tt/QWidget/ contains a pre-defined event handling that has to be overwritten for processing events on custom
widgets. Mind that as a guideline to define own event handling, you should reimplement <tt/QObject::event()/ for all classes that do
not inherit <tt/QWidget/ and the more specialized event handlers described below for all <tt/QWidget/ inherited classes. Also, preserve
the declarations as virtual protected to ensure reusability and consistency for your code.

<sect1>Event Types<label id="Event Types">
<p>
The events sent to the application are, as described, converted by <tt/QEvent/ to Qt events. The event type can be found out by using
the <tt/type()/ method of <tt/QEvent/, which can then be compared with the event that you want to know about. Now, the event type that
<tt/type()/ delivers is an integer number; those are declared with #define in the file <tt/qevent.h/.<footnote>Qt 2.0 uses an <tt/enum/
for all available event-types whose entries are similar to the current defines but generally leave out the <tt/Event_/ prefix. The
event type can be retrieved as described above, so you only have to change the comparison of the event type.</footnote>After filtering
events for the specialized event class, more information can be found out by explicit conversion to the event class to retrieve exact
data about the event.

<bf/Example:/
<code>
bool MyClass::event( QEvent* event ){

  if( event->type() == Event_MouseButtonPress){
    if( (QMouseEvent*)event->button() == RightButton ){
      // do something with the event, eg. pop up a contextmenu
      return true;
    }
    else{
      return false;
    }
  }
  else return false;
}
</code>
The event has been explicitely converted to <tt/QMouseEvent*/ here to find out the button type. You could also find out the position of
the mouse pointer at the time of the event, see the following section about mouse events

As there are so many event types that can occur, I have sorted the events defined in <tt/qevent.h/ logically according to the general
event type and the subclasses that provide an event handling and offer the exact information about specific events. The sorting
contains:

<itemize>
<item><ref id="Window Events" name="Window Events">
<item><ref id="Focus Events" name="Focus Events">
<item><ref id="Mouse Events" name="Mouse Events">
<item><ref id="Keyboard Events" name="Keyboard Events">
<item><ref id="Drag'n Drop Events" name="Drag'n Drop Events">
</itemize>

This will allow you to logically have a look at what might be interesting to reimplement or use before having to browse the Qt online
documentation in depth.

<sect2>Window Events<label id="Window Events">
<p>
By window events, all events that are produced by the window system in regards to handling any visible part of the application windows.
This does also include the event processing in the other direction, because by methods like <tt/QWidget::close()/ or
<tt/QWidget::repaint()/ events are sent to the window system to execute a synthetic events to manipulate the window behavior (either
inside the window or affecting the whole window).

This is sometimes a bit hard to understand, so I will give another short example here. Assuming you have an application that has a
window on the desktop. This window can be manipulated by the user through actions like:
<itemize>
<item>resizing
<item>moving
<item>obscuring with another window
<item>closing
<item>showing by execution
</itemize>

These are incoming events that are sent to the application. The event type is determined by <tt/QWidget/'s <tt/event()/
re-implementation and converted to the according event class that provides methods to handle the event specifically. Now, when you have a
look at the <tt/QWidget/ class, a lot of methods are provided for window manipulation, e.g. <tt/resize()/. You're using these methods,
but you probably never thought about their way of execution. In effect, these methods work the other way round: they produce an event
that is sent to the display by <tt/qt_/ functions to execute actions like simulating a user action. This way, events can also be
produced to gain synthetic events ( see below ).

Within a window, the widgets are arranged somehow. As each widget is treated like a separate window internally (it always is a
<tt/QWidget/ or inherits it), the same events can be processed randomly inside the window for incoming events as well as manipulating
internal parts of a window.

The following chart shows the according event classes with the event types they process:

<itemize>
<item><bf/QShowEvent:/ Processed by <tt/QWidget::show()/
	<itemize>
	<item>Event_Show
	</itemize>
<item><bf/QHideEvent:/ Processed by <tt/QWidget::hide()/
	<itemize>
	<item> Event_Hide
	</itemize>
<item><bf/QCloseEvent:/ Processed by <tt/QWidget::close()/
	<itemize>
	<item>Event_Close
	<item>event handler: <tt/QWidget::closeEvent(QCloseEvent*)/
	</itemize>
<item><bf/QResizeEvent:/ Processed by <tt/QWidget::resize()/
	<itemize>
	<item>Event_Resize
	<item>event handler: <tt/QWidget::resizeEvent(QResizeEvent*)/
	</itemize>
<item><bf/QPaintEvent:/ Processed by <tt/QWidget::repaint()/ calling the event handler directly, and <tt/QWidget::update()/ which
generates a window system paint event.
 	<itemize>
	<item>Event_Paint
	<item>event handler: <tt/QWidget::paintEvent(QPainEvent*)/
	</itemize>
<item><bf/QChildEvent:/ not included in the release version of Qt; to handle these events reimplement <tt/QObject::event()/ or install
an event filter. Child events are inserting a child widget or removing it
 	<itemize>
	<item>Event_ChildInserted
	<item>Event_ChildRemoved
	<item>Event_LayoutHint
	</itemize>
</itemize>
<footnote>Qt 2.0 includes another event class <tt/QWheelEvent/ to handle events that occur by wheel-mice. The <tt/QWidget/ class also
provides an already existing event handler for this, <tt/wheelEvent(QWheelEvent*)/. Also all drag'n drop events have their
event-handlers already in <tt/QWidget/, see the notes for drag'n drop</footnote>

<sect2>Focus Events<label id="Focus Events">
<p>
Focus events are somehow special to windows, but I have added a separate section for those due to the filtering of focus events in
<tt/QWidget/. A focus event is generally the fact that a window consists of several widgets who have a focus policy, which means that
there can only be one widget at a time that can have the current input focus. The focus itself can be activated by a mouse click to
activate the clicked widget or pressing the TAB key to forward the focus to the next widget in the tabring focus. Backwards focus
setting can be done with SHIFT+TAB. This is a common usability and users expect windows to have this behavior so they can navigate the
focus to the next widget. A good example for this is a dialog. If the dialog is a modal widget, it has to be finished first, otherwise
is active when it gets the focus if it is the active window. Now, on dialogs widgets can be disabled as well to prohibit any user
input. These disabled widgets don't get the focus either and are painted disabled.

The <tt/QWidget/ class defines the focus handling already when receiving an event. If the event type is <tt/Event_FocusIn/, the widget
gets the keyboard focus by <tt/event()/'s conversion into a <tt/QFocusEvent/.

This already catches a key event of the keys TAB and the combination SHIFT+TAB without processing these keys to <tt/QKeyEvent/ if
there is a widget the focus can be forwarded to. Anyway, you can influence this filtering by setting focus policy. The focus policy
can be set to:
<itemize>
<item><bf/QWidget::TabFocus/ TAB-focusing
<item><bf/QWidget::ClickFocus/ focus on mouse clicks
<item><bf/QWidget::StrongFocus/ focus on TAB and mouse clicks
<item><bf/QWidget::NoFocus/ no focus at all
</itemize>

The <tt/QFocusEvent/ class delivers information about the focus event by comparing the event type with <tt/type()/. The method
<tt/gotFocus()/ returns true on <tt/Event_FocusIn/ and <tt/lostFocus()/ returns true on <tt/Event_FocusOut/. The <tt/QWidget/
predefined event handlers are:

<list>
<item>focusInEvent(QFocusEvent*) for Event_FocusIn
<item>focusOutEvent(QFocusEvent*) for Event_FocusOut
</list>

You have a lot of choices to influence the default focus handling by the methods provided by <tt/QWidget/, e.g. you can forward the
focus to another widget with setting another focus order. Mind that the focus is arranged in a ring and your implementation of this
manipulation should take care that it doesn't break the focus handling. The default focus ring depends on the declaration of your
widgets while constructing; if your tests result in a fuzzy focus order you have to recheck the declaration. The default design should
always be left to right and top to bottom for forwarding the tab-focus. When using the geometry layout management you should declare
your widget order first and then implement the layout.

<tt/Hint:/ if your widgets use multilineedits, the user expects the tab key to produce a tab in the text, not the forwarding of the
focus. Therefore a simple method is to use <tt/setFocusPolicy(NoFocus)/ or <tt/setFocusPolicy(ClickFocus)/on all additional widgets
that are in the current window. Menubars and Toolbars do not have the tabfocus by default, so you don't have to set the focus policy
there. An exception is the <tt/QWhatsThis/ button, which although mostly used in a toolbar, receives the input focus on TAB.

<sect2>Mouse Events<label id="Mouse Events">
<p>
Mouse events are, as the word says, generated by the user's handling of the mouse. As these will only be of interest if the mouse is
over a widget, the best use to process mouse events is to reimplement the virtual methods <tt/QWidget/ provides for this. Now, the
window system sends the following event types to the application by mouse actions:

<list>
<item>Event_MouseButtonPress
<item>Event_MouseButtonRelease
<item>Event_MouseButtonDblClick
<item>Event_MouseMove
</list>

This means, that the user can handle the mouse with moving the cursor in X and Y direction, press any button and release it. A button
can also be doubleclicked, which is a special event and requires special handling. As the event message is filtered by the <tt/event()/
method of <tt/QWidget/, these event types are converted from a <tt/QEvent/ to a <tt/QMouseEvent/. Then, the mouse event is processed,
whereby <tt/QWidget/ provides a set of event handlers already. What is interesting about a mouse event is not only the type, but the
other parameters, as mentioned, to implement certain actions on specific events. One of the most recently used event types are probably
a right button press over a widget to open a context menu to allow quick access to commands that are available. This requires the exact
position of the event's occurrence and a comparison of the button type. Double clicks are processed by the user as producing a mouse
press event followed by a mouse release event and another mouse press event. As the time between the release and the next press cannot
be easily determined, the <tt/QApplication/ class has methods to define the click time which is by default 400 milliseconds:
<tt/QApplication::setDoubleClickInterval(int ms)/ is what you need.

The <tt/QMouseEvent/ class allows finding out the exact event by providing information about:
<bf/Button type:/ using <tt/button()/
<list>
<item>NoButton
<item>LeftButton
<item>RightButton
<item>MidButton
</list>

<bf/Mouse Position:/
<list>pos() : relative mouse position within the widget (x,y)
<item>globalPos() : absolute mouse position on the desktop (x,y)
<item>globalX() : global x position of the mouse pointer from left to right
<item>globalY() : global y position of the mouse pointer from top to bottom
<item>x(): relative mouse position within the widget from left to right
<item>y(): relative mouse position within the widget from top to bottom
</list>

<bf/Additional Keyboard presses at the same time:/ using <tt/state()/ and OR'ed with Left,Right and MidButton
<list>
<item>ShiftButton
<item>ControlButton
<item>AltButton
</list>

The provided event handlers are:
<itemize>
<item>Event_MouseButtonPress
  <itemize>
  <item>virtual void mousePressEvent ( QMouseEvent * )
  </itemize>
<item>Event_MouseButtonRelease
  <itemize>
  <item>virtual void mouseReleaseEvent ( QMouseEvent * )
  </itemize>
<item>Event_MouseButtonDblClick
  <itemize>
  <item>virtual void mouseDoubleClickEvent ( QMouseEvent * )
  </itemize>
<item>Event_MouseMove
  <itemize>
  <item>virtual void mouseMoveEvent ( QMouseEvent * )
  </itemize>
</itemize>

Thereby, the <tt/mouseDoubleClickEvent()/ by default only produces a mousePressEvent. You have to reimplement the
<tt/mouseDoubleClickEvent()/ to receive the event and process it as it is produced as an hypothetic event, not produced by the window
system under X11. Set the double click time with <tt/QApplication::setDoubleClickInterval()/.

For MouseMove events, you have to watch that the mouse event is only handled if a button is pressed. This can be configured by
<tt/QWidget::setMouseTracking(true)/ to receive all mouse movements as <tt/QMouseEvent/s in the event handler. The implementation
therefore is on QWidget: the event is raised, <tt/event()/ asks if mousetracking is set to true. If not (default), the event is
ignored, if yes, the event is converted to a <tt/QMouseEvent/ and delivered to the <tt/mouseMoveEvent()/ event handler.

Additionally, the widget can detect if the mouse enters the widget's space. This is done by filtering out the mouse movement before
generating the <tt/QMouseEvent/ in <tt/QWidget::event()/:

<itemize>
<item>Event_Enter
  <itemize>
  <item>virtual void enterEvent ( QEvent * )
  </itemize>
<item>Event_Leave
  <itemize>
  <item>virtual void leaveEvent ( QEvent * )
  </itemize>
</itemize>

An example for reimplementing an enter and leave event is <tt/QToolButton/. The buttons in the toolbar have a automatic raising
behavior in windows style, therefore the widget uses an enter event to raise the button in 3D and lowers it when the mouse leaves the
widget area.<footnote>Wheel mice are offering an additional functionality for scrolling by the wheel. Qt 2.0 offers solutions for
handling wheel events in a separate event class <tt/QWheelEvent/, therefore these are not handled as mouse-events.</footnote>

<sect2>Keyboard Events<label id="Keyboard Events">
<p>
A keyboard event is generally sent to the application if the user pressed or released a keyboard button, therefore can determine the
event by:
<list>
<item>Event_KeyPress
<item>Event_KeyRelease
</list>

<sect3>Handling
<p>
Now, the <tt/QWidget/ class converts a keyboard event from <tt/QEvent/ to a <tt/QKeyEvent/ if the widget has the keyboard input focus;
if the widget has tabfocus policy, the TAB and SHIFT+TAB key-presses are filtered out to produce a <tt/QFocusEvent/ instead a
<tt/QKeyEvent/. The <tt/QKeyEvent/ class provides more convenient methods to process the key event. Those have some specialties which
I want to discuss.

<bf/Event Handlers:/

<tt/QWidget/ provides two event handlers for the two event types the keyboard produces:
<list>
<item>virtual void keyPressEvent(QKeyEvent*) for Event_KeyPress
<item>virtual void keyReleaseEvent(QKeyEvent*) for Event_KeyRelease
</list>

<bf/Acceptance:/

The widget that receives a <tt/QKeyEvent/ and re-implements the event handlers from <tt/QWidget/ has to determine if it wants to accept
or ignore the keyevent, so the widget can sent it back to the parent widget. Therefore you have to know that the accept flag is set to
true in the constructor of a <tt/QKeyEvent/. You can clear this flag with calling <tt/ignore()/ if you don't want to process the key
and sent it back.

<bf/Modifiers/

The user can press so-called key-modifiers. Those are the ShiftButton, ControlButton and AltButton. The currently pressed modifier keys
can be found out with <tt/state()/, which returns the modifiers OR'ed together.

<bf/Key Values/

The key values for all keyboard keys are defined in the include file <tt/qkeycode.h/.<footnote>Qt 2.0 has all keycodes coded into
namespaces of the class <tt/Qt/ located in <tt/qnamespace.h/, <tt/enum keys/.</footnote> The key that produced the event can be
retrieved with <tt/key()/ and then compared to the defined keycode. The ASCII value can be found with <tt/ascii()/. Mind that the
symbolic constants for key values are platform independent and allow the best usage as they are simple to remind.

<sect3>Keyboard Accelerator Questions
<p>
A question that often occurs is the implementation of keyboard accelerators. As this handbook primarily targets KDE programming, I will
go into that as well.

Qt has a class <tt/QAccel/ which offers connections of key presses with actions. This is done by installing an event filter that
filters out keyboard events that match any item inserted into the <tt/QAccel/ object. The keyboard accelerator itself has to be a
combination of the <tt/CTRL/, <tt/SHIFT/ or <tt/ALT/ keys with a normal keyboard key. Another value can be <tt/ASCII_ACCEL/ here to use
the ASCII keyboard value for the accelerator.

An accelerator instance is then created by using the widget that it should work for as an event filter with the widget as its parent.
Insert the keys with <tt/insertItem(keycode, ID )/. Although setting the ID is not necessary, you should write yourself a logical ID
table containing integer value defines that allow using the ID later to find the accelerator item and helps keeping an overview over
the used numbers.

Then, the item has to be connected to the object and slot it shall work for on its signal <tt/activated(int ID)/ using the
<tt/connectItem()/ method instead of the usual <tt/QObject::connect()/ variant.

Popup menus (only within menu-bars) already provide accelerator usage without explicitely creating a <tt/QAccel/ instance. You only have
to use <tt/setAccel()/ there; see <tt/QMenuData/ for more details.

Now, when it comes to KDE, things will be a bit different because KDE offers some additional features. First of all, you have to use
the class <tt/KAccel/ instead of <tt/QAccel/; the usage is almost the same. The <tt/KAccel/ class (part of <tt/kdecore/) also offers an
insertion into menus and configuration of accelerator keys, which then can change the menu entry as well.

Further, KDE provides globally configured accelerators for standard keys.Those are defined in <tt/kaccel.h/ and only have to be
inserted. The class documentation also shows the usage of standard accelerators and accelerators in general by examples.

Whenever an application offers keyboard accelerators, users often feel uncomfortable with the given values and want to change them
themselves. Also, the programmer usually sets keyboard accelerators for those slots that he thinks are the most needed functions in his
program; in fact he should in any case add accelerators to all of his available menu entries and functions. Further, KDE has two ways to
offer configurating the <tt/KAccel/ object as well as saving the configuration to the application config file by providing a ready-to
use dialog for configuration as well as a widget that can be used within a custom configuration dialog (most often a tab dialog) to
configure the keys.

For accelerator configuration dialogs, see section <ref id="Keyboard Accelerators" name="Keyboard Accelerators">.


<sect2>Drag'n Drop Events<label id="Drag'n Drop Events">
<p>
One of the most advanced techniques to allow application communication is drag'n drop. This offers users a cool and fast feature to
handle the objects they work with in an application by an intuitive interface, catching it by a symbolic icon or by marking parts of a
document and move the dragged object away from the current area. The area the dragged object comes from is therefore called a
<tt/dragsource/. Then the user moves the object away to another area of the application, to the desktop or into the area of another
application. After releasing the mouse button over there, he expects the data dragged to be dropped into the drop area. Therefore the
drop area is also called a <tt/drop site/ or a <tt/drop sink/. The window system provides a protocol for this, the XDND protocol, which
causes the emission of the according events. The application windows can support these events by providing methods to drag object out
of the window and methods to accept a drop event. Qt implements this by a class <tt/QDropSite/.<footnote>Qt 2.0 makes this a lot
easier. <tt/QWidget/ already contains all event handlers that are mentionend here for the class <tt/QDropSite/, therefore you only have
to remove the inheritance from <tt/QDropSite/ of your drag'n drop enabled widget and add a call to <tt/setAcceptDrops(TRUE)/ in the
widget's constructor.</footnote> The widget that wants to use drag'n drop has to inherit this class additionally to the base widget
class. Then, the <tt/QDropSite/ offers additional event handlers that convert the <tt/QEvent/ types for drag'n drop to one of the
according specialized event classes. The programmer also has to take care in his re-implementation of the mouse event handlers by which
mouse button holding a drag can occur. Also, Qt currently provides two types of data to decode, text and images, which should be the
most common usage. The following chart contains the window system events, the event classes handling these events and the event
handlers of <tt/QDropSite/:

<itemize>
<item>Event_DragEnter
	<itemize>
	<item>QDragEnterEvent
	<item>event handler:virtual void dragEnterEvent(QDragEnterEvent*)
	</itemize>
<item>Event_DragMove
	<itemize>
	<item>QDragMoveEvent
	<item>event handler:virtual void dragMoveEvent(QDragMoveEvent*)
	</itemize>
<item>Event_DragLeave
	<itemize>
	<item>QDragLeaveEvent
	<item>event handler:virtual void dragLeaveEvent(QDragLeaveEvent*)
	</itemize>
<item>Event_Drop
	<itemize>
	<item>QDropEvent
	<item>event handler:virtual void dropEvent(QDropEvent*)
	</itemize>
</itemize>
The event handlers are all implemented as public and reimplementations should preserve to

<bf/Note:/ the system event <tt/Event_DragResponse/ is automatically handled by the application object internally through the
Qt implementation. It causes a <tt/QDragResponseEvent/ that accepts/rejects the drag action.

<comment>KDE also contains another implementation of Drag'n Drop functionality. The description of using KDE 1.x Drag'n Drop has been
left out because this will be removed in KDE 2 and only the Qt implementation is going to be used with an extended implementation of
the XDND protocol.</comment>

<comment>
There exists a zoo of DND protocols. At the moment of writing, the Qt DND protocol does
<em/not/ support the Motif DND protocol (as used by for instance Netscape and GNOME).
Please be aware of this if you reimplement the Qt DND functions.
</comment>


<sect>QWidget Virtual Methods
<p>

As the event handling generally is implemented by virtual protected methods, especially the <tt/event()/ method provided by
<tt/QObject/, the <tt/QWidget/ class reimplements this function in order to sort out the incoming event and convert it to other event
types that can be handled by more specialized classes. Furthermore, it calls the provided additional virtual methods by default
implementations. The programmer has a good advantage by this pre-selection of events as the widgets he creates are all derived from
<tt/QWidget/ and therefore will need one or more special event handler implementation. The most common events that are processed are
mouse events and for text input mostly keyboard events. The other events mostly deal with focus handling, which moves on the keyboard
input focus from one widget to the next. Programmers need to know about focus handling well, because the user will expect a certain
behavior over his widget when using the TAB key and the SHIFT+TAB combination to move the input focus forward.

Like explained in the Event Queue chapter, the <tt/QApplication/ takes care of converting window system events to objects of the
<tt/QEvent/ class that are handled by the <tt/QObject::event()/ method. Therefore all classes that are derived from <tt/QObject/ can
process event handling. The class <tt/QWidget/ already contains an overwritten <tt/event()/ method. It first checks for installed event
filters (which are additionally created event filters by the programmer to redefine the default behavior by processing the event
themselves or only the wanted events). Then it decides by the <tt/type()/ of the event which kind of event was called and converts it
to one of the following event classes derived from <tt/QEvent/ who are delivered to the according virtual methods:

<itemize>
<item>QCloseEvent
	<itemize>
	<item>virtual void closeEvent ( QCloseEvent * )
	</itemize>
<item>QFocusEvent: keyboard input focus event; widget gets the focus and looses it due to preselection of TAB and SHIFT+TAB by
<tt/event()/ 	
	<itemize>
	<item>virtual void focusInEvent ( QFocusEvent * )
	<item>virtual void focusOutEvent ( QFocusEvent * )
	</itemize>
<item>QMouseEvent: mouse events
	<itemize>
	<item>virtual void mousePressEvent ( QMouseEvent * )
	<item>virtual void mouseReleaseEvent ( QMouseEvent * )
	<item>virtual void mouseDoubleClickEvent ( QMouseEvent * )
	<item>virtual void mouseMoveEvent ( QMouseEvent * ) :with pressed mouse button by default. Use <tt/setMouseTracking(true)/ to receive
all movements
 	</itemize>
<item>QMoveEvent: window move event, position change
	<itemize>
	<item>virtual void moveEvent ( QMoveEvent * )
	</itemize>
<item>QKeyEvent: keyboard events
	<itemize>
	<item>virtual void keyPressEvent ( QKeyEvent * )
	<item>virtual void keyReleaseEvent ( QKeyEvent * )
	</itemize>
<item>QResizeEvent: widget is resized
	<itemize>
	<item>virtual void resizeEvent ( QResizeEvent * )
	</itemize>
<item>QPaintEvent: widget needs repainting
	<itemize>
	<item>virtual void paintEvent ( QPaintEvent * )
	</itemize>
</itemize>

Additionally, two events are called that don't match any other event type but may be important sometimes:

<bf/virtual void enterEvent ( QEvent * ):/ the mouse enters the widget space

<bf/virtual void leaveEvent ( QEvent * ):/ the mouse leaves the widget space

Reimplementing is always needed if your custom widget wants to process the event and react to it. The reason why the event gets split
up to other <tt/QEvent/ types is that the other event classes provide methods that are suitable to directly retrieving the needed
event-specific data. This means, that e.g. a <tt/QMouseEvent/ can be asked for the button that caused the event or was active at that
particular event as well as the global and relative mouse position where the event occurred. Mouse events are always used to pop up
context menus over widgets which need to know the button (right mousebutton) and the position, because the user expects the context
menu to pop up at the same position the mouse cursor currently is.

The paint event is often needed if a widget has to draw something. Instead of creating a synthetic event (a logical event caused by the
program internally), call repaint() here.


<sect>Event Filters
<p>
In addition to the normal processing of the event queue that is provided by the application object, the programmer can influence the
default behavior by installing event filters. As explained above, all <tt/QObject/ inherited classes use event processing through the
<tt/event()/ method. Instead of writing a completely new event handler in situations where you only need some events processed by your
own methods, you should write an event filter. The event filter gets installed where you like to and filters out the event directly
when <tt/QObject::event()/ is called internally.

To write an event filter, your class has to overwrite the <tt/QObject::eventFilter()/ method and call <tt/installEventFilter()/ as
well as <tt/removeEventFilter()/. The declaration of these methods in <tt/QObject/ are:

<tscreen><verb>
bool QObject::eventFilter ( QObject *, QEvent * ) [virtual]
void QObject::installEventFilter ( const QObject * obj )
void QObject::removeEventFilter ( const QObject * obj )
</verb></tscreen>

The implementation of an event filter can be done in several ways. One that is possible is to create a new class for special event
filters and create an instance of this class in the program. Then you can install the event filter on every instance you like to to
achieve the same event filter on all instances independent of their class as well as redefining event processing of existing classes
without inheriting them.

An example would be:

<tscreen><verb>
// Classdeclaration

class KMyAppFilter: public QObject
{
protected:
  virtual bool eventFilter(QObject* object, QEvent* event);
};

// Filterimplementation

bool KMyAppFilter::eventFilter(QObject* object, QEvent* event){

  if(event->type() == [the eventtype you like to filter])
  {
    [your filter implementation]
    return true;  // the event has been caught and processed
  }
  else
  {
    return false; // return false to continue processing the event with QObject::event()
  }
}

// installing the filter

QObject* myfilter= new KMyAppFilter();
QPushButton* mybutton= new QPushButton();

mybutton->installEventFilter(myfilter);
</verb></tscreen>

Another solution would be to reimplement the <tt/eventFilter()/ method in your inherited class as long as the base class is
<tt/QObject/, e.g. if your view area of your application wants to process a certain event that is not covered by the virtual methods
<tt/QWidget/ provides. Then you have to install the event filter at the place you like to; normally this would be in the constructor of
your class. With removeEventFilter() you can stop the event filter from processing the events any time.

<comment>Note: <tt/KApplication/ already has a global application event filter installed to filter out CTRL+ALT+F12 for
KDebug</comment>

<sect>Synthetic Events
<p>
Before describing what synthetic events are and how they can be used by the programmer, I want to review the last sections briefly.

We saw that the application object receives the window system events, processes them and creates event objects from the classes the
library provides. The converted event can then be handled by event handlers that are specialized on the event class to retrieve further
information about the event. Finally, we can influence the event handling itself by installing event filters and overwriting provided
event handlers.

This does the "normal" job of an application to execute actions according to user invoked events. On the other side, this system offers
another possibility: the fact that the events are converted to class instances can be reversed - a so-called synthetic event can be
created which fakes an original window system event. The next advantage is that these events are independent of the underlying window
system.

A good possibility where this feature could be used would be e.g. for learning programs. Those are almost non-existent for Unix but
could offer a market to teach beginners how to handle programs similar to commercial products already available on other platforms.
Also this could be a part of a help-system which an application can provide.

An example description how to implement this:

Provide a help window with a button that invokes a step e.g. "Show me". On pressing the button, the cursor will move to the desired
location, e.g. to a pushbutton on the screen. The implementation then has to find out the exact position of the button and calculate
the center coordinates the mouse pointer has to move to. Then the mouse pointer could move there by construction of a <tt/QCursor/ and
using <tt/setPos()/. The start position can be found out in the mouse event that called the function. Then, the cursor has to move
visually by using <tt/setPos()/ in a loop where a <tt/QTimer/ could be used to run between positions to slow down the move so that the
user can follow the mouse pointer.

<sect1>Creating Events
<p>
Now, to come to the actual implementation of a synthetic event, you have to know the event you want to create. Therefore, you need the
constructor parameters for the event classes. The following list contains the constructors including the event-classes hierarchy:

<descrip>
<tag/QEvent(int type)/ <tt/type/ is one of the events declared in <tt/qevent.h/<footnote>Qt 2.0 uses all events from an <tt/enum/
instead of the #defines. See <tt/QEvent/. The types are almost the same except they leave out the <tt/Event_/ prefix.</footnote>

<tag/QCloseEvent()/ takes no parameter. Mind that the accept flag is set to false

<tag/QFocusEvent(int type)/ <tt/type/ is either <tt/Event_FocusIn/ or <tt/Event_FocusOut/.

<tag/QKeyEvent(int type, int key, int ascii, int state)/ takes <tt/Event_KeyPress/ and <tt/Event_KeyRelease/ as <tt/type/.
<tt/key/ is one of the keys defined in <tt/qkeycode.h/. <tt/state/ is <tt/ShiftButton, ControlButton, AltButton/ OR'ed. 	

<tag/QMouseEvent (int type, const QPoint & pos, int button, int state)/ The <tt/type/ parameter must be
<tt/Event_MouseButtonPress, Event_MouseButtonRelease, Event_MouseButtonDblClick/ or <tt/Event_MouseMove/. The <tt/button/ is
<tt/LeftButton, RightButton, MidButton, NoButton/. <tt/state/ is <tt/ShiftButton, ControlButton and AltButton/ OR'ed for event
<tt/Event_MouseButtonRelease/, for events <tt/Event_MouseButtonPress, Event_MouseButtonDblClick/ <tt/state/ includes <tt/LeftButton,
RightButton, MidButton/.
	
<tag/QMoveEvent(const QPoint & pos, const QPoint & oldPos)/ <tt/pos/ is the new position the widget shall move to, <tt/oldPos/ the
old position. Retrieve the old position before creating the event with <tt/QWidget::pos()/.

<tag/QPaintEvent(const QRect & paintRect) / raise a paint event to repaint the area <tt/paintRect/
	
<tag/QResizeEvent(const QSize & size, const QSize & oldSize)/ resizes the widget from <tt/oldSize/ to <tt/size/. Retrieve the old
size before creating the event with <tt/QWidget::size()/.
</descrip>

An example on how to create an event would be:

<tscreen><verb>
QMouseEvent press_quit(Event_MouseButtonPress,
                       quit_button->pos(), LeftButton, LeftButton);
</verb></tscreen>

This creates a mousePressEvent() for the widget <tt/quit_button/ with the left button.


<sect1>Sending Events
<p>
After creation, the event has to be sent to the application instance to call its execution. Thereby, two ways can be used: one that
directly processes the event and one that will place the event in the event queue at the last position:

Direct execution:
<tscreen><verb>
QApplication::sendEvent(quit_button, &amp;press_quit);
</verb></tscreen>
The <tt/sendEvent()/ waits for the result and returns true or false depending if the event has been accepted or not.


Placement into event queue:
<tscreen><verb>
QApplication::postEvent(quit_button, &amp;press_quit);
</verb></tscreen>
<comment>The event for postEvent() must be allocated on the heap as it gets deleted immediately after the posing.</comment>


To turn a posted event into a send event, use <tt/sendPostedEvents(QObject * receiver, int event_type)/. This requires the options
given at the constructor. As you may see, some constructors don't need an event type, therefore the according event type can be found
in <ref id="Event Types" name="Event Types"> but is also simple to guess as they are only responsible for one event type. Example:
<tt/QCloseEvent/ only takes <tt/Event_Close/, <tt/QPaintEvent/ only takes <tt/Event_Paint/.


<sect>Event Precedence
<p>

In relation to influence the event behavior of the application, the programmer often faces situations where long operations block the
<tt/Event_Paint/ and lead to a scrambled look of the application windows. These situations can be solved either by using a
progressdialog that indicates the operation progress or by event precedence. This means that the current event gets stopped and the
event queue is processed. The class <tt/QApplication/ offers a solution for this by two methods which are identical except the
parameters. One is <tt/processEvents()/, which processes pending events for 3 seconds or until there are no more events in the event
queue. The other, more likely used method is <tt/processEvents(int maxtime)/, where <tt/maxtime/ is the time in milliseconds during
which pending events can be processed.

On one hand this means stopping the current long operation which then would take even longer to get finished if pending events are in
the queue, but the user cares more about the visible state of an application than if an operation which takes some time will take a
second longer (or even parts of a second).

KDE offers an additional library for I/O operations in the upcoming KDE 2, which is under development. This will allow running the long
I/O operations outside the application's process as multi-threading is not supported by Qt directly.


<sect>Summary
<p>
After this long chapter about signals, slots and events, I want to append a short summary so you can recapitulate the collected
knowledge about application behavior.

<itemize>
<item>An application can communicate internally by signals and slots
<item>Signals are sent out without caring about who will catch it
<item>Slots are normal methods that can connect to signals and react as well as they can be called where allowed by their access attribute
<item>Slots cannot have default arguments
<item>Slots return void
<item>The user communicates with the application through the window system
<item>The window system reports the events to the application
<item>The application converts window system events to <tt/QEvent/s
<item>The events are processed through an optional application global event filter
<item>The event that passes the filter gets forwarded to the according window e.g. the current modal window
<item>The widget receives the event and can have an event filter that comes first when the reimplemented <tt/QObject::event()/ is
called.
<item>If the event passes the widget event filter, <tt/event()/ proceeds to convert it to the according <tt/Q***Event/ class
<item>The event filters for these event types are called to react on the event
</itemize>

Further, we saw that the programmer can influence the behavior by:

<itemize>
<item>reimplementing any stage of virtual methods filtering events
<item>creating synthetic events
<item>sending synthetic events directly or into the event queue
<item>the event queue can be given precedence that stop long processes to allow execution of waiting events to be processed
</itemize>

Finally, I hope this has given at least experienced C++ programmers a good insight and explanation on how Qt and KDE work. I have
collected the information by working myself into the class structure and I hope that this collection makes it a lot easier for other
programmers to get started especially in the advanced chapters of application design and programming. The information value is
therefore not granted to be exact; if you may find any misconcepted or incorrect information, please contact me via email.

<chapt>User Control Elements
<p>

<sect>The Menubar<label id="The Menubar">
<p>
The menu bar is a central component of the main window. It allows the user to execute operations that the application (or to be precise:
the mainview) offers in regards of manipulating the main view's contents. In opposition to Qt's <tt/QMenuBar/, KDE offers the use of
the class <tt/KMenuBar/. Additionally, the menu bar is already constructed for the programmer when using <tt/KTMainWindow/ with the
first call of <tt/menuBar()/.

The menu bar itself, independent which class is going to be used, contains entries that the user can select with the mouse or by using
keyboard accelerators with the ALT-key and the underlined character. The menus that have to pop up on a selection have to be created
with the class <tt/QPopupMenu/, which itself only provides the popups, entries have to be inserted using the methods provided by
<tt/QMenuData/.

Mind that menu-bars should always contain all functions a program has to offer except those that can be accessed by additional dialogs.
The menu bar also makes use of the <tt/KApplication/ help menu already provided. Inserting the menu is just easy with

<tscreen><verb>
menuBar()->insertItem(i18n("Help"), kapp->getHelpMenu());
</verb></tscreen>

Example construction of a menu bar with using <tt/KTMainWindow/ and setting the menu bar explicitely:
<code>
my_menubar=new KMenuBar(this,"my_menubar");

file_menu = new QPopupMenu;
file_menu->insertItem(Icon("filenew.xpm"),i18n("&amp;New..."),
                      this,SLOT(slotFileNew()),0,ID_FILE_NEW);
file_menu->insertItem(Icon("open.xpm"),i18n("&amp;Open..."),
                      this, SLOT(slotFileOpen()),0 ,ID_FILE_OPEN);
file_menu->insertItem(i18n("&amp;Close"),
                      this, SLOT(slotFileClose()),0,ID_FILE_CLOSE);
file_menu->insertSeparator();
file_menu->insertItem(Icon("save.xpm"),i18n("&amp;Save"),
                      this, SLOT(slotFileSave()),0 ,ID_FILE_SAVE);
file_menu->insertItem(i18n("Save &amp;As..."),
                      this, SLOT(slotFileSaveAs()),0 ,ID_FILE_SAVE_AS);
file_menu->insertItem(Icon("save_all.xpm"),i18n("Save All"),
                      this, SLOT(slotFileSaveAll()),0,ID_FILE_SAVE_ALL);
file_menu->insertSeparator();
file_menu->insertItem(Icon("fileprint.xpm"),i18n("&amp;Print..."),
                      this, SLOT(slotFilePrint()),0 ,ID_FILE_PRINT);
file_menu->insertSeparator();
file_menu->insertItem(i18n("E&amp;xit"),
                      this, SLOT(slotFileQuit()),0 ,ID_FILE_QUIT);

my_menubar->insertItem(i18n("&amp;File"), file_menu);

setMenu(my_menubar);
</code>

The example creates a menu bar and a popup menu first. Then the popup menu is filled with entries. The used method of <tt/QMenuData/
here allows an implicit connection to the method to call when the popup menu emits SIGNAL(activated(int)). The zero parameters after
the slot declaration is left out as the example assumes the program will use <tt/KAccel/ to set the according keyboard accelerators
with <tt/changeMenuAccel()/. Further you can see that the integer value ID is inserted like the method name with all uppercase letters
and underscores to separate the words. The menu id's themselves are set with #define in a separate file to keep track of the used
numbers. You would think that you don't need the menu id if the <tt/activated()/ signal is already connected - in fact the id can be
used to forward the signal <tt/highlighted(int)/ to a method that compares the id by a switch statement and sets a statusbar
help message for the menu entry. You could as well do that for the signal <tt/activated(int)/ as well to call the according method by a
switch statement. Then you have to add a <tt/connect()/ for each popup menu you want to use.

You can as well insert a separator into the menu bar with <tt/my_menubar->insertSeparator()/. This will align all entries inserted after
the separator to the right in Motif style, in windows style this has no effect.

The creation of a separate menu bar allows the creation of several menubars which can be set as the actual menu with <tt/setMenu()/.
This is how we did it in KDevelop to change the menu bar when switching to the dialogeditor and back to the project editor.

Finally, the ampersand in the menu entry sets the following character as the keyboard accelerator when the user presses ALT+ the
character.

<sect>The Toolbar
<p>

Toolbars are another component that enhance user interaction with symbols representing most needed functions that an application
provides. The KDE libraries are again offering another class to use with KDE applications, <tt/KToolBar/. As <tt/KTMainWindow/ already
handles the geometry management for all user interface elements, it also provides methods to add toolbars. Now, the good thing is that
you can use as many toolbars as your application may require and the creation is done easily with <tt/toolBar()/. This method also
takes a parameter which is the according toolbarnumber. The first toolbar has by default number 0, so the parameter can be left out
there; the next has to be called with <tt/toolBar(1)/ etc. You can also make this more variable with a define for your toolbar and use
a descriptive name; this avoids changing the toolbarnumber everywhere when you decide to set a toolbar to another position.

Now, when using a toolbar, you have many choices. The class <tt/KToolBar/ provides a whole set of methods to insert user elements such
as buttons, which is probably the most recently used method, delayed popups, lineedits, combos and generally a widget of your choice.
Further you need to know that toolbars are created with using the full width of the parent window - but that is configurable. All
following toolbars are then appended to the end of the last toolbar. Also you can set the toolbar to show at a certain position. This
is often used by applications that offer painting facilities. The following example shows you how to use a toolbar with
<tt/KTMainWindow/:

<code>
1   // first call of toolBar() - creates the toolbar 0.
2   toolBar()->insertButton(Icon("new.xpm"), ID_FILE_NEW, true, i18n("New File"));

3   QPopupMenu* select_menu = new QPopupMenu();
4   toolBar()->insertButton(Icon("select.xpm"), ID_OPTIONS_SELECT, select_menu, true, i18n("Select Option"));

5   connect(toolBar(), SIGNAL(clicked( int )), SLOT( slotSelected( int )) );


6   Foo::slotSelected( int id ){

7     switch (id ){

8       case ID_FILE_NEW:
9         slotFileNew();
10        break;
11    }
12  }
</code>
The above explains some specialities for toolbars - we will discuss these now in detail. First of all, you see that we used the
<tt/toolBar()/ method. This returns a pointer to the according toolbar and creates one if the toolbar doesn't exist. We use the
<tt/insertButton()/ method to add a toolbar button representing the standard "New File" action. Now, when looking at the
class-documentation of <tt/KToolBar/, you see that there is a <tt/QPixmap/ required as the first parameter. Here, we only set the name
of the pixmap embraced by the <tt/Icon()/ method. This is a macro which makes inserting icons very easy, provided by <tt/kapp.h/. In
fact, it makes the application's <tt/KIconLoader/ instance load the icon with the filename <tt/new.xpm/ for you using a list of
standard directories within the KDE File System. Additionally, the icon <tt/new.xpm/ is already provided - you don't have to paint it
yourself. The KDE libraries come with a whole set of toolbar icons that are ready to use for insertion. This is also the reason why,
when testing an application, sometimes a button looks a bit scrambled although you have painted the pixmap - it just can't be found if
it isn't installed at the correct location within the KDE FSSTD; whereas standard icons are already present.

The exact execution of the <tt/Icon()/ macro is therefore:
<tscreen><verb>
KApplication::getKApplication()->getIconLoader()->loadIcon("new.xpm")
</verb></tscreen>
<footnote>In KDE2, you have to use BarIcon() to load menu/toolbar icons
</footnote>

which implicitely uses the <tt/kapp/ macro to get the application object. You see that using this macro saves lots of code but offers a
very nice way to load an icon for a toolbar button.

The second parameter, the ID of the button, is a macro that our application specifies itself to name certain actions logically by a
#define. Obviously, you could think that using another method of <tt/KToolBar/ would do the same when directly specifying the receiver
object and the slot to call, but this way you save a lot of code. The first place is that you only have to write one <tt/connect()/
(line 5) to connect all toolbar elements. The other is, that by this way you can use the same ID for your toolbar items as well as for
your menubar items. The following code completes this example with the according menubar action:

<tscreen><verb>
QPopupMenu* file_menu = new QPopupMenu();
file_menu->insertItem(Icon("filenew.xpm"),i18n("&amp;New..."),0,ID_FILE_NEW);

connect(file_menu, SIGNAL(activated(int)), SLOT(slotSelected(int)));

menuBar()->insertItem(file_menu, i18n("&amp;File"));
</verb></tscreen>

By this, the <tt/file_menu/ is already connected to the <tt/slotSelected()/ method and the corresponding entry "New File" executes the
same action. Just collect all your ID's as #defines into one file and you can keep a good overview over the used numbers (which
naturally have to be integer values).

The next example in line 3 and 4 add a button that opens a popup menu when the user presses the button. This can be used if the button
itself does not perform any action but represents a better access method for e.g. a list of entries. Just create your popup menu and
insert it with the according ID and pointer as a button.

Besides the example you can do a lot of other things like making a button a toggle button. This is useful if the button executes an
on/off action (which in the corresponding menubar popup is represented by a checkmark). See the complete reference of <tt/KToolBar/ for
more information.

<sect>The Statusbar
<p>
KDE also provides the pendant to Qt's <tt/QStatusBar/, <tt/KStatusBar/. The statusbar can contain labels
as well as widgets, such as progress bars (those have to have the statusbar as parent). The statusbar is used to display information
about the current state of the application and gives hints about the usage of commands e.g. over toolbars and menubars.

<sect>Keyboard Accelerators<label id="Keyboard Accelerators">
<p>
Keyboard accelerators are a good enhancement for any kind of application. GUI application designers often think that the user can
access all methods with the provided graphical interface, but advanced users usually want to work as fast as possible and using the
mouse to call actions doesn't make an application very attractive. The more a user will make use of your application, the more he will
miss keyboard accelerators. Fortunately, the Qt and KDE libraries provide a whole set of functions and classes to support keyboard
accelerators in conjunction with GUI elements. This section therefore collects all these classes and shows the possible implememtation
for various situations.

<sect1>Menu Accelerators
<p>
The first thing where keyboard accelerators are used without much effort from the programmer's side is over menuentries. The menubar,
as mentioned above, consists of a set of <tt/QPopupMenu/s, which are inserted in the order they will appear later from left to right.
The popup menu itself can be called by the user by a keyboard shortcut if he presses the ALT-key together with the underlined character
of the desired menu of the menubar. The menuentry itself has to define the underlined character at the time you insert the popup into
the menubar.

Example:

<verb>
menuBar()->insertItem(i18n("&amp;File"), file_menu);
</verb>

Mind the ampersand in front of "File". This makes the "F" the key with which the user can pop up the popup menu <tt/file_menu/ when
pressed together with the ALT-key. The same goes with entries within the popups, where the user, after a popup is active, only has to
press the key to invoke the desired action. Selfexplaining, you should watch the usage of underlined characters very closely, because a
key that is used twice either in the menubar or within the same popup makes the last inserted item the one that is activated and this
makes the previously defined shortcuts useless.

Using the menu-accelerators is therefore very easy for the programmer - just select the key you want to be used and set an ampersand
in front of it while inserting the entry. As the KDE applications get internationalized, translators take over the responsibility to
place the keys in their translated version later. They should watch the same principles for placing the keys and shouldn't only
translate one-to-one but test the application later if everything is accessible again by their keyboard shortcuts.

<sect1>Tabulator and Button Accelerators
<p>

The keyboard accelerators with the ALT-key don't only work with the menus - they do the same over dialogs, tab-pages and on buttons.
Therefore it should be used whereever possible, the principle is the same: on a dialog, you have to watch the used keys, on e.g. a
<tt/QTabDialog/ you have to watch the keys for each page <bf/plus/ the used keys to activate the pages in the <tt/addTab()/ methods.

Within the user interface, buttons have an additional option - as mentionend, the keyboard input focus is forwarded in user interfaces
with the TAB and SHIFT-TAB keys. When a button receives the focus, it gets a slight frame like other active elements, the user has to
press the SPACE-key to execute the action connected to the button. Now, this can be changed by using <tt/setDefault(true)/ on one
button or by setting <tt/setAutoDefault(true)/ on several buttons on the dialog. The difference is that if the User presses the
ENTER-key, the default button will be pressed. If several buttons shall provide this behavoir, <tt/setAutoDefault()/ has to be used on
those. If one of them receives the keyboard input focus, it will automatically become the default button.


KKeyDialog: keyboard accelerator configuration dialog
KKeyChooser
KAccel

<sect>Other Widgets
<p>
Control elements are used within visible areas of the application and can be combined together to create a dialog or view. Beyond the
control elements that the Qt library provides, KDE offers:

KButton: active raise-lower button
KButtonBox: manages buttons
KColorButton: button displaying a color setting
KIconLoaderButton: button displaying a selected Icon
KCombo: similar to QComboBox
KDatePicker: Date selection widget
KIntegerLine: lineedit that only accepts integer values
KLedLamp: LED lamp
KLined: line edit
KPanner: panner devider
KNewPanner: panner devider managing two widgets
KPopupMenu: popup menu with title
KRestrictedLine: lineedit that only accepts certain input
KSelector: value selector
KSeparator: standard separator
KSlider: slider widget
KTabCtl: tabulator widget

<chapt>KDE Dialogs
<p>
A very useful thing of the KDE libraries is that they provide already constructed dialogs for various purposes that are common to a lot
of desktop applications. This has two reasons: a) the user feels comfortable using these dialogs if he knows them already from an
application and b) lessens the programmer's work a lot. In section <ref id="Keyboard Accelerators" name="Keyboard Accelerators">, you
already got to know one of these dialogs that KDE provides to configure keybindings. For the other dialogs that are mostly part of the
<tt/kdeui/ library, the usage is mostly as simple as for the <tt/KKeyDialog/ and enhances applications within seconds of coding
efforts. You should always first look for an already existing solution for general value requests from the user before starting to
implement a new dialog from scratch. Further, you don't have to care about internationalization as these dialogs are part of the KDE
libraries and are already translated.

<sect>KMsgBox
<p>
The <tt/KMsgBox/ class provides a whole set of message boxes that match everyday life usage in applications. Using KMsgBox has a lot of
advantages: you can use one of the static methods to retrieve results on standard questions and you can still influence the behavior by
setting text, window text, symbol and button text.

<itemize>
<item>message(): providing a single message box with an OK button to inform the user
<item>yesNo(): provides a yes/no question box.
<item>yesNoCancel(): provides a yes/no/cancel box with three buttons. Used e.g. to quit an application with the question: Document has
been modified. Would you like to save changes ?. Then the yes-button would mean saving changes and exiting the application, no would
mean exit without saving and cancel would stop any exiting and just returns.
</itemize>

If this doesn't match your actual need, you could as well create a new KMsgBox instance that can have up to four buttons. This can be
used by applications that have multiple open files but don't want the user to ask if he would like to save changes for each file
separately; therefore these will need a button "Save All" or something. Then you could program the dialog towards your needs like the
static methods and will receive the correct result.

As usual with dialogs, the return value is that what a programmer usually has to process by retrieving it into a variable and then
compare with <tt/if()/ for the actions to execute.
<footnote>The KDE 2 API contains a modified version of <tt/KMsgBox/, <tt/KMessageBox/. It provides a similar functionality; the 1.x API
is no longer available. As a replacement, you can use <tt/QMessageBox/, providing static methods as well.</footnote>

<sect>KQuickHelp
<p>

The <tt/KQuickHelp/ class provides a good way to add quick-help dialogs to widgets. The user can access the quick-help by a
context-menu entry "Quick-Help" and is therefore easy to use and gives enough information where a Help-button for the manuals would be
too much and a <tt/QToolTip/ would be too less. The reason I include <tt/KQuickHelp/ into the provided dialogs is that the
class-documentation itself contains example usage, but doesn't cover all formatting possibilities, therefore these are listed in detail
here.

<footnote>In KDE2, KQuickHelp is no longer available and is replaced by QWhatsThis, which has almost the same API</footnote>

<sect1>Usage
<p>
A quick-help window therefore can always be added to a widget by using the static method <tt/add()/, also one help message can be used
for more than one widget. The example shows this by adding one message that applies to two widgets that are providing a funcitionality
that depends on each other:

<code>
#include <kquickhelp.h>
#include <kapp.h>
#include "mydialog.h"

MyDialog::MyDialog(QWidget* parent, const char* name): QDialog(parent, name)
{

  file_lineedit= new QLineEdit(this, "file_lineedit");
  file_select_button= new QPushButton(this, "file_select_button");

  KQuickHelp::add(file_lineedit,
  KQuickHelp::add(file_select_button, i18n("Select the filename to process.\n"
                                           "You can use the lineedit or the\n"
                                           "button to select the filename.")));
}
</code>

<sect1>Text Formatting
<p>

The text inside your quick-help window can also be formatted to fit various needs, even hyperlinks. Using the KDE-FSSTD, you can also
access your online-documentation to provide a link for further information by just using your html filename. This is considered a nice
way to give the user the best information in some cases where the purpose of certain functions is too difficult to explain in a
quick-help window.

The followindg list contains the valid tags for text formatting:

<code>
Font Attributes           Tag                                         Short-form Tag

bold font                 &lt;bold&gt;&lt;/bold&gt;                   &lt;b&gt;&lt;/b&gt;
italic font               &lt;italic&gt;&lt;/italic&gt;               &lt;i&gt;&lt;/i&gt;
underlines                &lt;underline&gt;&lt;/underline&gt;         &lt;u&gt;&lt;/u&gt;
</code>

<code>
Font Size                 Tag                                         Short-form Tag

increase                  &lt;FONTSIZE +&gt;                          &lt;+&gt;
decrease                  &lt;FONTSIZE -&gt;                          &lt;-&gt;
</code>

<code>
Font Selection            Tag                                         Short-form Tag

default font              &lt;FONT DEFAULT&gt;                        &lt;DEFAULT&gt;
fixed font                &lt;FONT FIXED&gt;                          &lt;FIXED&gt;
</code>

<code>
Indentation               Tag                                         Short-form Tag

right indent              &lt;INDENT +&gt;                            &lt;i+&gt;
left indent               &lt;INDENT -&gt;                            &lt;i-&gt;
</code>

<code>
Color

RGB color                 &lt;COLOR #&gt;
red text                  &lt;COLOR RED&gt;                           &gt;&lt;red&gt;
green text                &lt;COLOR GREEN&gt;                         &lt;green&gt;
blue text                 &lt;COLOR BLUE&gt;                          &lt;blue&gt;
white text                &lt;COLOR WHITE&gt;                         &lt;white&gt;
yellow text               &lt;COLOR YELLOW&gt;                        &lt;yellow&gt;
black text                &lt;COLOR BLACK&gt;                         &lt;black&gt;
brown text                &lt;COLOR BROWN&gt;                         &lt;brown&gt;
magenta text              &lt;COLOR MAGENTA&gt;                       &lt;magenta&gt;
cyan text                 &lt;COLOR CYAN&gt;                          &lt;cyan&gt;
</code>

<code>
Newline                   &lt;br&gt;
Hyperlinks                &lt;link linkname&gt;&lt;/link&gt;
</code>

Thereby, valid <tt/linkname/s are:

<itemize>
<item>http://yourlink
<item>info://yourlink
<item>ftp://yourlink
<item>file://yourlink
<item>mailto:your_address@your_domain
</itemize>
These links will be opened using the <tt/kfm/ (KDE File Manager). All other linknames assume that you want to access your application's
online-help documentation and therefore use the <tt/linkname/ as the file you want to access and tries to open it with the KDEHelp
program.


<sect>File Dialogs
<p>
As the <tt/kfile/ library provides several dialogs for retrieving filenames as well as directories, those have to be separated towards
which class and method to use for which purpose.

Generally, the <tt/kfile/ library offers:
<itemize>
<item>a <tt/KFileDialog/ class, which is a specialized <tt/KFileBaseDialog/ and provides the most needed static methods to retrieve
filenames.
<item>the <tt/KFileDialog/ class itself, which can be subclassed but also be used for retrieving several filenames and directories.
<item>the <tt/KFilePreviewDialog/ class, which offers file-dialogs that can display selected files by their contents if the developer
provides a preview module that is able to show a preview of the filecontents
</itemize>

For general file/directory services, the classes <tt/KFileInfo/ and <tt/KDir/ can be used.

The following sections will discuss the usage and handling of the according file-dialogs in applications.

<sect1>KFileDialog
<p>

The <tt/KFileDialog/ class provides four static methods to ask the user for a filename. As the filedialog itself can handle the
creation of new folders, storing bookmarks etc, the user will be thankful if you use this dialog to ask for a filename to open and a
filename to save files to. The <tt/KFileDialog/ class itself is a specialized class that is based on <tt/KFileBaseDialog/, so if the
given methods don't fit your needs you can always inherit from <tt/KFileBaseDialog/ to customize the settings.

The following examples show the usage for each purpose:

<tscreen><verb>
// request a filename to open

QString open_filename;
open_filename=KFileDialog::getOpenFileName()

if(!open_filename.isEmpty())
{
  // read the file
}
</verb></tscreen>

This asks the user for a filename to open. The <tt/KFileDialog/ shows and retrieves the information. If the user cancels the
filedialog, the return string will be null, therefore you have to test first if <tt/QString::isEmpty()/ doesn't return <tt/true/ before
opening the file actually.

The same goes with the static methods <tt/getSaveFileName()/, <tt/getOpenFileURL()/, <tt/getSaveFileURL()/, whereby each function takes
parameters to set the starting directory, mime-types and, as usual, the <tt/QWidget/ <tt/parent,name/ parameters.

The parallel methods for <tt/getSaveFile/ and <tt/getOpenFile/ behave identically for retrieving remote and/or local files with the URL
dialogs.

<sect1>KFileBaseDialog
<p>
The class <tt/KFileBaseDialog/ provides the basic interfaces for building filedialogs; therefore filedialogs can be customized in wide
ranges towards your needs and is the most flexible way to construct filedialogs. Besides that, the class provides additional
functionality for other standard cases like retrieving a directory name. Further functionality can be achieved by inheritance.

<bf/Retrieving a directory name/

The class provides retrieving a directory name by the static method <tt/getDirectory()/. The following example shows the usage:

<tscreen><verb>
QString the_directory;

the_directory=KFileBaseDialog::getDirectory();

if(!the_directory.isEmpty())
{
	// do something
}
</verb></tscreen>
<footnote>Of course, you can also use <tt/KFileDialog/ instead of <tt/KFileBaseDialog/ if you like your API to be more
consistent.</footnote>


<sect1>KFilePreviewDialog
<p>
The class <tt/KFilePreviewDialog/ provides another specialized, but more seldomly used filedialog. Its best feature is that it provides
an area where the programmer can use a preview widget for his file format to open. The best usage is made within graphic programs that
operate on pictures.

<sect>KColorDialog
<p>
The <tt/KColorDialog/ provides an easy-to use interface to receive color values from the user. Color values are always requested, if
the application is a drawing or painting program to select the current brush as well as for e.g. KDevelop's dialogeditor to set color
values for widgets.

The usage itself is often combined with a <tt/KColorButton/, which is a specific <tt/QPushButton/ implemented in <tt/kdeui/ that
displays a color and calls the <tt/KColorDialog/ already when the user presses the button. Anyway, you can call the color dialog from
your menu bar or toolbar as well to retrieve a color value from the user.

Using the colordialog is very easy inside applications. The class provides a static method which can be called to retrieve the color
value:

<code>
#include &lt;kcolordlg.h&gt;


QColor myColor;

int result = KColorDialog::getColor( myColor );

</code>

This creates an instance of QColor to store a color value and by calling the static method <tt/getColor()/ the color gets the selected
value. The returned integer value will probably be of no interest - its the result code of <tt/QDialog/ that specifies the dialog has
been exited via the OK or Cancel button.


<sect>KFontDialog
<p>
The <tt/KFontDialog/ will retrieve you a value for a font currently avaliable on the system. Therefore using the fontdialog will mostly
only make sense where you will need a font; the most recent usage is made by text editors but could also be used to get a
formatting for a text to draw inside a widget as well as into a picture.

To retrieve the font value, you probably will use the static methods of <tt/KFontDialog/. The example shows the usage:

<code>
  QFont myFont;
  int res = KFontDialog::getFont( myFont );
</code>

This is it already - you only have to create a <tt/QFont/ instance to contain the font value. Then call the font dialog with the font
and after the dialog was executed, your font will have the selected value. Then you have the methods of <tt/QFont/ to determine which
type of font the user selected etc. to use the font within the application.


<sect>KIconLoaderDialog
<p>
For applications requiring an icon selection, KDE provides the <tt/KIconLoaderDialog/. The main purpose is to select an icon on the
system to draw it on a button for example. Usage is made by the KDE window manager to select the icons for mounted/unmounted states of
device links. Then the values for the link are displayed on the according button to display the current selection; the filenames get
stored in the link file and can be drawn on the desktop as a symbol by loading the icons dependent on the state of the connected
device. There, an additional widget of the <tt/kdeui/ libary is used, the <tt/KIconLoaderButton/. Like the <tt/KColorButton/, this
class will call the icon loader dialog when the user presses the button and will display the selected icon on the button.

As the <tt/KIconLoaderDialog/ class does not provide any static methods, you have to create an instance first and then call
<tt/QDialog/'s <tt/exec()/ method to display the dialog. Another possibility would be to call <tt/selectIcon()/ to execute the dialog
but retrieve a <tt/QPixmap/ value instead. The selected Icon will be in your <tt/KIconLoader/ instance (depending on the used
constructor which one - the standard constructor uses the application's <tt/KIconLoader/), therefore the value can be processed with
the according methods of <tt/KIconLoader/.


<sect>KWizard
<p>
The <tt/KWizard/ class already contains a predefined dialog to construct wizards that lead the user through an input process. Thereby,
the wizard dialog provides the necessary buttons and draws the according page numbers already, so that you only have to construct your
widgets you want to use as the single pages for the dialog and insert them in the order you want the user to proceed while calling the
wizard.


<sect>KSpellDlg
<p>

The <tt/KSpellDlg/ is part of the <tt/kspell/ library. This library contains all functionality to use the <tt/Ispell/ application for
spell checking. The <tt/KEdit/ application makes a good use of this library, so you should take a look at the implementation of
<tt/KEdit/ on how to implement spell checking functionality. Using the <tt/KSpell/ class should last in any case.

<sect>DatePickerDialog
<p>


(kab) date selection dialog

<sect>Qt Dialogs
<p>
In some cases, it may be needed to use dialogs provided by Qt. In fact, the only dialog where there are no replacements is a
progressdialog and a printing dialog. Of course you could construct one yourself, but the Qt library offers some good solutions for
these situations. The following will give you a short overview where to find what you need.

Important: When using Qt dialogs, including QTabDialog for new dialogs, you have to set the labels again with <tt/i18n()/ to enable
internationalization.

Example:
<code>
QTabDialog tabdlg = new QTabDialog();
tabdlg->setDefaultButton(i18n("Default"));
tabdlg->setCancelButton(i18n("Cancel"));
tabdlg->setApplyButton(i18n("Apply"));
tabdlg->setOkButton(i18n("OK"));
</code>
This will add all four buttons to the tabdialog, so you should only set those buttons you really need.


<sect1>QFileDialog
<p>
Using the QFileDialog, you will have the same functionality like KFileDialog. The KDE development prefers the KFileDialog for a
consistent look of applications as it offers some nice functionality as well.


<sect1>QMessageBox
<p>
As mentioned in section KMsgBox, the QMessageBox can be used as well for messages. One situation where a QMessageBox can serve better
is a messagebox containing a picture for example. Usage is provided through static methods which should cover most cases.

<sect1>QPrintDialog
<p>
For printing support, you will most likely use the QPrintDialog. As a view-widget displays a document's contents, it will most likely
offer routines for printing as well through QPainter drawing on a QPrinter instead of onto a widget.

<sect1>QProgressDialog
<p>
When an application is processing data that may take some time to finish, the user expects a notification about that state. For those
cases, Qt provides the QProgressDialog.  As the class is well documented, including example code for usage, you should take a look at
the according API documentation.

<chapt>Provided Views
<p>
As mentioned earlier, a usual application interface contains a so-called "view" or "content" area, usually the center widget surrounded
by menubar, toolbars and a statusbar. Besides the required construction of a view widget by inheritance of <tt/QWidget/, the KDE and Qt
libraries offer several complete widgets that can serve as view areas already.  These are widgets that are used commonly over a lot of
applications and do not necessarily have to be used as a main view; they may also get used in dialogs.

Qt only offers one of these: the <tt/QMultiLineEdit/ class, offering a text editing widget. By using a <tt/QMultiLineEdit/, a developer
can create a full-functional editor rapidly. The class interface may also serve you as an example what functionality a view area should
provide.

KDE on the other hand contains two complete widgets. One is again an editor widget, derived from <tt/QMultiLineEdit/ and is
encapsulated in the <tt/KEdit/ class of the <tt/kdeui/ library; the other a HTML- interpreter widget, <tt/KHTMLWidget/. The following
will discuss these classes and explain the interface usage by example.

<sect>The KEdit View
<p>
As mentioned, the <tt/KEdit/ view is a full-functional editor class that offers a complete interface to build an editor. As it inherits
<tt/QMultiLineEdit/, it makes use of Qt's basic functionality with the intention to complete the interface beyond the facilities a text
editor view should provide such as insertion or clipboard communication.

The idea is to construct a <tt/KTMainWindow/ based main view with the according items like a menubar, toolbar and statusbar. The
slots that get called by the popup menus or the toolbar icons are all placed as public methods within the <tt/KEdit/ class. This
requires the implementation of slots on the main widget that call the according methods.

An example containing a slot implementation and the use of a slot provided already by <tt/QMultiLineEdit/:
<code>
void MyEditor::initMenuBar(){

  // create the "Edit" menu
  edit_menu= new QPopupMenu();
  // here we call a slot selectAll() provided by QMultiLineEdit to select the whole text:
  edit_menu->insertItem(i18n("&amp;Select All"), kedit, SLOT(selectAll()), 0, ID_EDIT_SELECT_ALL);

  // construct a view-menu and insert a menuentry "Font"
  view_menu= new QPopupMenu();
  // we have to call a self-created slot to call
  // the public method selectFont() of KEdit
  view_menu->insertItem(i18n("&amp;Font"), this, SLOT(slotViewFont()), 0, ID_VIEW_FONT);


  // insert the view_menu into the menubar
  menuBar()->insertItem(i18n("&amp;Edit"), edit_menu);
  menuBar()->insertItem(i18n("&amp;View"), view_menu);
}

void MyEditor::slotViewFont(){
  // call a method of KEdit to call the font selection dialog
  selectFont ();
}
</code>


<sect>The KHTML View
<p>
The second view area provided by KDE is originally the <tt/KHTMLWidget/. This class actually is the visible widget that interprets HTML
files including graphics, tables etc. What it doesn't offer is a scrolling functionality which limits the use of the widget. Therefore,
the class <tt/KHTMLView/ is introduced which serves as a wrapper class that offers this and other functionality.

A lot of applications make wide use of either <tt/KHTMLWidget/, adding the scrolling functionality by code, or using <tt/KHTMLView/
directly, such as KDEHelp, KDevelop and KFM.

The main reason for a complete HTML widget is that today's applications tend to use HTML-based help functionality almost everywhere, so
a reuse of this funcitionality is very certain.

The usage can be compared to the implementation example of the last chapter for <tt/KEdit/, as <tt/KHTMLView/ provides signals, slots
and public methods as well that can be called similar to provide a user interface that handles the widget. When it comes to configuring
the behavoir of the displaying <tt/KHTMLWidget/, you have to create a pointer to a <tt/KHTMLWidget/ and retrieve the instance of your
<tt/KHTMLView/'s widget by calling <tt/getKHTMLWidget()/. Then you can set options like color settings and font sizes for your view
area.
<comment>In KDE2 you will have an extended KHTMLWidget that directly inherits QScrollView, so scrolling is provided by default.
KHTMLView is removed instead. Also, the new HTML widget provides support for Java Script.</comment>


<chapt>Process Handling
<p>
The KDE UI library provides the classes <tt/KProcess/ and <tt/KShellProcess/ to run external processes that are invoked within the
application that needs to run another application. This has generally two advantages:

<itemize>
<item>you don't have to reinvent the wheel when commandline programs already exist
<item>your application's event queue is not blocked by long operations
</itemize>

A lot of applications already make wide use of these classes as they are very flexible and provide the necessary interface not only to
start another application but to control its output and termination. As mentioned, a lot of Unix applications are already available
but only work on commandline. The commandline arguments are hard to remember and most users won't ever touch them if they don't need
them really. For occasional usage, the interface is too complex and therefore not very user-friendly. As KDE applications target a
desktop system where even unexperienced users can feel themselves at home, this is the best way to write so-called front-ends for
terminal applications.

Another possible use even for KDE programmers would be to write their target application as a commandline program and provide a
user-friendly GUI interface.

The following sections will describe the <tt/KProcess/ class first, then the usage of <tt/KShellProcess/, as this is a subclass of
<tt/KProcess/, therefore differs only in its usage.

<sect>KProcess
<p>

The <tt/KProcess/ class is based on <tt/QObject/, therefore able to communicate by signals and slots. It can be used to start any
executable binary as a child process on the local system and control it by communication and run mode. To use <tt/KProcess/, include
<tt/kprocess.h/ and create an instance of <tt/KProcess/. If the instance has been created and used already, you have to call
<tt/clearArguments()/ to ensure the arguments are empty before the next usage. The actual usage is to transmit the complete commandline
argument to the process instance using the operator << as strings. Then the actual process is called with <tt/start()/. This function
has to be called with the run mode and communication.

<sect1>Run mode
<p>
The run mode of the external application can be set when calling <tt/start()/ as the first argument. The run mode can be one of
<tt/DontCare, NotifyOnExit, Block/. Now, what does this mean to the application that is called and to the application that calls the
process ?

<itemize>
<item>DontCare: The child process is called and started with the given commandline arguments. Easy to guess, DontCare means that the
caller is not interested if the child process has exited or not. The two applications run concurrently, but the invoking process
(usually the GUI application) doesn't get notified and runs like without starting any process.

<item>NotifyOnExit: both processes run concurrently like in DontCare run mode. The difference is that the process controller can emit
the signal <tt/processExited()/, which can be caught to determine the child process has finished. The notification can be used to reset
any statusbar message informing the user that the process is running, this should be used as a guideline to inform the user about the
current state of the application. Mind that the invoking application is responsible for the child process as it is unlikely that
non-experienced users will control and other process that they see.

<item>Block: the child process blocks the caller's event handling and program execution. This is not recommended to use within GUI
applications as even the call <tt/processEvents()/ won't be executed; therefore the event handling cannot be called to execute even by
event precedence.
</itemize>

The <tt/start()/ method also returns if the start has been successful or not. Therefore you should always call the method with an
<tt/if()/ statement to display a message box if starting the process returns false. Reasons for <tt/start()/ to return false could be:
<itemize>
<item>the commandline argument list is empty (which is your implementations's fault)
<item>the process which is to be called is already running
<item>starting the child process failed
</itemize>

To inform the user why the process cannot be executed, you have to investigate these three possibilities. The first possibility, an
empty commandline, depends on your GUI that provides the methods setting the commandline options. Normally, you would retrieve them
by a dialog where the user sets the options on how to start the application. The GUI for these dialogs normally uses radio buttons to
let the user choose one of several options (or more if the process allows this), a lineedit for filenames (with an additional
file-selection button to call a <tt/KFileDialog::getOpenFileName()/), eventually a lineedit for output locations, also with a
<tt/KFileDialog::getSaveFileName()/.

The second possibility mostly occurs in situations where the application has been started twice or the user has opened another instance
of its main window where or by which he caused another process call. In this case, you could use <tt/getPid()/  to determine the
current process ID which can be used in a message box to show that the process is already running.

Finally, failing a call of a child process often means that the program is not available on the system. There, you should inform the
user that he has to install the program to ensure functionality. Another option would be to test the <tt/PATH/ environment variable of
the user for the directories he uses to call applications. Then you could test with <tt/QFile::exists()/, if the binary is there even
before trying to start it.

<sect1>Communication
<p>
The communication with the caller process is another option that has to be set while calling <tt/KProcess::start()/. With this, you can
retrieve the output of the process where needed. The available communication modes are:

<itemize>
<item>NoCommunication : Use when you don't want to communicate with the process, e.g. it runs silently without interesting output or
requiring any input.
<item>Stdin : To be used if the process asks for user input. Depending on the process, you have to use this communication mode to avoid
blocking - the process just will wait for input but can never retrieve the information if this mode isn't used.
<item>Stdout : The output the process sends to StdOut, which would be your terminal for example. This mode has to be used if you want
to retrieve the output information for displaying it to the user in a widget.
<item>Stderr : error messages sent by the process to StdErr can be retrieved seperately by this mode. This is useful to check for
errors.
<item>AllOutput : Stdout and Stderr OR'ed together. Mind that this doesn't include StdIn communication !
<item>All: Open all communication channels, meaning that Stdout, Stderr and Stdin are OR'ed together.
</itemize>

As mentioned for <tt/AllOutput/ and <tt/All/ communication modes, the available modes can be OR'ed together to combine the needed
modes.

By the according signals and slots, you can connect the communication data channels to e.g. a text widget or a buffer. Displaying the
output directly into a text widget will be used for Stdout in most cases while error messages can as well be retrieved into a
non-visible buffer which can be processed to visualize errors by messageboxes.

<sect>KShellProcess
<p>

The <tt/KShellProcess/ class is a specialized <tt/KProcess/ class. The main difference is that you can call your executable via a Unix
shell which allows all options the selected shell offers. You should check for available shells as well before calling a shell process
for a special shell; the normal constructor will check for any shell available but can be set to use e.g. /bin/bash to make use of the
Bourne shell - but you can't expect any system to have the Bourne shell available. The use of a <tt/KShellProcess/ offers the following
advantages:
<itemize>
<item>Useage of environment variables
<item>Setting environment variables
<item>pipe usage
<item>wildcard usage
</itemize>

The methods of <tt/KProcess/ then offer the necessary communication and runmodes the process may need.


<chapt>Copyright<label id="Copyright">
<p>
<tscreen><verb>

KDevelop Copyright 1998,1999 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>

</book>























