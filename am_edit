#!/usr/bin/perl

# Expands the specilised KDE tags in Makefile.in to (hopefully) valid
# make syntax.
# When called without file parameters, we work recursively on all Makefile.in
# in and below the current subdirectory. When called with file parameters,
# only those Makefile.in are changed.
# The currently supported tags are
#
# {program}_METASOURCES
# where you have a choice of two styles
#   {program}_METASOURCES = name1.moc name2.moc ... [\]
#   {program}_METASOURCES = AUTO
#       The second style requires other tags as well.
#
# and more new tags TBD!
#
# The concept (and base code) for this peogram came from automoc,
# supplied by the following
#
# Matthias Ettrich <ettrich\@kde.org>      (The originator)
# Kalle Dalheimer <kalle\@kde.org>      (The original implementator)
# Harri Porten  <porten@tu-harburg.de>
# Alex Zepeda  <garbanzo@hooked.net>
# David Faure <faure@kde.org>
# Stephan Kulow <coolo@kde.org>
#
# I've puddled around with automoc and produced something different
# 1999-02-01 John Birch <jb.nz@writeme.com>
#       * Rewritten automoc to cater for more than just moc file expansion
#         Version 0.01 does the same as automoc at this stage.
# 1999-02-18 jb
#       * We must always write a Makefile.in file out even if we fail
#         because we need the "perl autokmake" in the AUTOMAKE so that a
#         "make" will regenerate the Makefile.in correctly.
#         Reworked moc file checking so that missing includes in cpp
#         will work and includes in cpp when using use_automoc will also
#         work.
# 1999-02-23 jb
#       * Added POFILE processing and changed the USE_AUTOMOC tag to
#         AUTO instead.

use Cwd;
use File::Find;
use File::Basename;

# Prototype the functions
sub initialise ();
sub processMakefile ($);
sub updateMakefile ();
sub restoreMakefile ();

sub removeLine ($$);
sub appendLines ($);
sub substituteLine ($$);

sub findMocCandidates ();
sub pruneMocCandidates ($);
sub checkMocCandidates ();
sub addMocRules ();

sub tag_AUTOMAKE ();
sub tag_META_INCLUDES ();
sub tag_METASOURCES ();
sub tag_POFILES ();
sub tag_DOCFILES ();
sub tag_LOCALINSTALL();
sub tag_IDLFILES();
sub tag_TOPLEVEL();
sub tag_SUBDIRS();
sub tag_ICON();
sub tag_CLOSURE();

# Some global globals...
$verbose    = 0;        # a debug flag
$thisProg   = "$0";     # This programs name
$topdir     = cwd();    # The current directory
@makefiles  = ();       # Contains all the files we'll process
$start      = (times)[0]; # some stats for testing - comment out for release
$version    = "v0.2";
$errorflag  = 0;
$cppExt     = "*.cpp *.cc *.cxx *.C *.c++";           # used by grep
$hExt       = "*.h *.H *.hh *.hxx *.h++";             # used by grep
$progId     = "KDE tags expanded automatically by " . basename($thisProg);
$automkCall = "\n";
$printname  = "";  # used to display the directory the Makefile is in
$use_final  = 1;        # create code for --enable-final
$cleantarget = "clean";
$dryrun     = 0;

while (defined ($ARGV[0]))
{
    $_ = shift;
    if (/^--version$/)
    {
        print STDOUT "\n";
        print STDOUT basename($thisProg), " $version\n",
                "This is really free software, unencumbered by the GPL.\n",
                "You can do anything you like with it except sueing me.\n",
                "Copyright 1998 Kalle Dalheimer <kalle\@kde.org>\n",
                "Concept, design and unnecessary questions about perl\n",
                "       by Matthias Ettrich <ettrich\@kde.org>\n\n",
                "Making it useful by Stephan Kulow <coolo\@kde.org> and\n",
                "Harri Porten <porten\@kde.org>\n",
                "Updated (Feb-1999), John Birch <jb.nz\@writeme.com>\n",
	        "Current Maintainer Stephan Kulow\n\n";
        exit 0;
    }
    elsif (/^--verbose$|^-v$/)
    {
        $verbose = 1;       # Oh is there a problem...?
    }
    elsif (/^-p(.+)$|^--path=(.+)$/)
    {
        $thisProg = "$1/".basename($thisProg);
        warn ("$thisProg doesn't exist\n")      if (!(-f $thisProg));
    }
    elsif (/^--help$|^-h$/)
    {
        print STDOUT "Usage $thisProg [OPTION] ... [dir/Makefile.in]...\n",
                "\n",
                "Patches dir/Makefile.in generated from automake\n",
                "(where dir can be a full or relative directory name)",
                "\n",
                "  -v, --verbose      verbosely list files processed\n",
                "  -h, --help         print this help, then exit\n",
                "  --version          print version number, then exit\n",
                "  -p, --path=        use the path to am_edit if the path\n",
	        "  --no-final         don't patch for --enable-final\n",
                "                     called from is not the one to be used\n";
	
        exit 0;
    }
    elsif (/^--no-final$/)
    {
	$use_final = 0;
        $thisProg .= " --no-final";
    }
    elsif (/^-n$/)
    {
    	$dryrun = 1;
    }
    else
    {
        # user selects what input files to check
        # add full path if relative path is given
        $_ = cwd()."/".$_   if (! /^\//);
        print "User wants $_\n" if ($verbose);
        push (@makefiles, $_);
    }
}

# Only scan for files when the user hasn't entered data
if (!@makefiles)
{
    print STDOUT "Scanning for Makefile.in\n"       if ($verbose);
    find (\&add_makefile, cwd());
    #chdir('$topdir');
} else {
    print STDOUT "Using user enter input files\n"   if ($verbose);
}

foreach $makefile (@makefiles)
{
    processMakefile ($makefile);
    last            if ($errorflag);
}

# Just some debug statistics - comment out for release as it uses printf.
printf STDOUT "Time %.2f CPU sec\n", (times)[0] - $start     if ($verbose);

exit $errorflag;        # causes make to fail if erroflag is set

#-----------------------------------------------------------------------------

# In conjunction with the "find" call, this builds the list of input files
sub add_makefile ()
{
    push (@makefiles, $File::Find::name)  if (/Makefile.in$/);
}

#-----------------------------------------------------------------------------

# Processes a single make file
# The parameter contains the full path name of the Makefile.in to use
sub processMakefile ($)
{
    # some useful globals for the subroutines called here
    local ($makefile)       = @_;
    local @headerdirs       = ('.');
    local $haveAutomocTag   = 0;
    local $MakefileData     = "";

    local $cxxsuffix  = "KKK";

    local @programs = ();  # lists the names of programs and libraries
    local $program = "";

    local %realObjs = ();  # lists the objects compiled into $program
    local %sources = ();   # lists the sources used for $program
    local %finalObjs = (); # lists the objects compiled when final
    local %realname = ();  # the binary name of program variable
    local %idlfiles = ();  # lists the idl files used for $program
    local $allidls = "";
    local $idl_output = "";# lists all idl generated files for cleantarget

    local %depedmocs = ();

    local $metasourceTags = 0;
    local $dep_files      = "";
    local $dep_finals     = "";
    local %target_adds    = (); # the targets to add
    local $kdelang        = "";

    $makefileDir = dirname($makefile);
    chdir ($makefileDir);
    $printname = $makefile;
    $printname =~ s/^\Q$topdir\E\///;
    $makefile = basename($makefile);

    print STDOUT "Processing makefile $printname\n"   if ($verbose);

    # Setup and see if we need to do this.
    return      if (!initialise());

    tag_AUTOMAKE ();            # Allows a "make" to redo the Makefile.in
    tag_META_INCLUDES ();       # Supplies directories for src locations

    foreach $program (@programs) {
	tag_METASOURCES ();         # Sorts out the moc rules
	tag_IDLFILES();             # Sorts out idl rules
	tag_CLOSURE();
    }

    if ($idl_output) {
      appendLines ("$cleantarget-idl:\n\t-rm -f $idl_output\n");
      $target_adds{"$cleantarget-am"} .= "$cleantarget-idl ";
    }

    if ($MakefileData =~ /\nKDE_LANG\s*=\s*(\S*)\n/) {
      $kdelang = '$(KDE_LANG)'
    } else {
      $kdelang = '';
    }

    tag_POFILES ();             # language rules for po directory
    tag_DOCFILES ();            # language rules for doc directories
    tag_TOPLEVEL ();            # language rules for po toplevel
    tag_LOCALINSTALL();         # add $(DESTDIR) before all kde_ dirs
    tag_ICON();

    my $tmp = "force-reedit:\n";
    $tmp   .= "\t$automkCall\n\tcd \$(top_srcdir) && perl $thisProg $printname\n\n";
    appendLines($tmp);

    tag_FINAL() if ($use_final);

    my $final_lines = "final:\n\t\$(MAKE) ";

    foreach $program (@programs) {

      my $lookup = "$program\_OBJECTS.*=[^\n]*";

      my $new = "";

      my @list = split(/[\034\s]+/, $realObjs{$program});

      if ($use_final && @list > 1 && $finalObjs{$program}) {
	
	$new  = "\@KDE_USE_FINAL_FALSE\@$program\_OBJECTS = " . $realObjs{$program};
	$new .= "\n\@KDE_USE_FINAL_TRUE\@$program\_OBJECTS = " . $finalObjs{$program};
	$new .= "\n$program\_final\_OBJECTS = " . $finalObjs{$program};

	$final_lines .= "$program\_OBJECTS=\"\$($program\_final_OBJECTS)\" ";

      } else {
	$new = "$program\_OBJECTS = " . $realObjs{$program};
      }

      substituteLine ($lookup, $new);
    }
    appendLines($final_lines . "all-am");

    my $lookup = 'DEP_FILES\s*=([^\n]*)';
    if ($MakefileData =~ /\n$lookup\n/) {
      $depfiles = $1;


      if ($dep_finals) {
	$lines  = "\@KDE_USE_FINAL_TRUE\@DEP_FILES = $dep_files $dep_finals \034\t$depfiles\n";
	$lines .= "\@KDE_USE_FINAL_FALSE\@DEP_FILES = $dep_files $depfiles\n";
      } else {
	$lines = "DEP_FILES = $dep_files $depfiles\n";
      }

      substituteLine($lookup, $lines);
    }

    my $cvs_lines = "cvs-clean:\n";
    $cvs_lines .= "\t\$(MAKE) -f \$(top_srcdir)/admin/Makefile.common cvs-clean\n";
    appendLines($cvs_lines);

    $cvs_lines  = "kde-rpo-clean:\n";
    $cvs_lines .= "\t-rm -f *.rpo\n";
    appendLines($cvs_lines);
    $target_adds{"clean"} .= "kde-rpo-clean ";

    foreach $add (keys %target_adds) {
      my $lookup = "$add:\s*(.*)";
      if ($MakefileData =~ /\n$lookup\n/) {
	substituteLine($lookup, "$add: " . $target_adds{$add} . $1);
      }
    }

    my $found = 1;

    while ($found) {
      if ($MakefileData =~ m/\n(.*)\$\(CXXFLAGS\)(.*)\n/) {
	my $vor = $1;
	my $nach = $2;
	my $lookup = quotemeta("$1\$(CXXFLAGS)$2");
	my $replacement = "$1\$(KCXXFLAGS)$2"; 
	$MakefileData =~ s/$lookup/$replacement/;
	$lookup =~ s/\\\$\\\(CXXFLAGS\\\)/\\\$\\\(KCXXFLAGS\\\)/;
	$replacement = "$vor\$(KCXXFLAGS) \$(KDE_CXXFLAGS)$nach";
	substituteLine($lookup, $replacement);
      } else {
	$found = 0;
      }
    }

    $MakefileData =~ s/\$\(KCXXFLAGS\)/\$\(CXXFLAGS\)/g;

    # Always update the Makefile.in
    updateMakefile ();
    return;
}

#-----------------------------------------------------------------------------

# Check to see whether we should process this make file.
# This is where we look for tags that we need to process.
# A small amount of initialising on the tags is also done here.
# And of course we open and/or create the needed make files.
sub initialise ()
{
    if (! -r "Makefile.am") {
	print STDOUT "found Makefile.in without Makefile.am\n" if ($verbose);
	return 0;
    }

    # Checking for files to process...
    open (FILEIN, $makefile)
      || die "Could not open $makefileDir/$makefile: $!\n";
    # Read the file
    while ( <FILEIN> )
    {
        $MakefileData .= $_;
    }
    close FILEIN;

    # Remove the line continuations, but keep them marked
    # Note: we lose the trailing spaces but that's ok.
    $MakefileData =~ s/\\\s*\n/\034/g;

    # If we've processed the file before...
    restoreMakefile ()      if ($MakefileData =~ /$progId/);

    if ($MakefileData =~ /\nKDE_OPTIONS\s*=\s*([^\n]*)\n/) {
      my @kde_options = split(/[\s\034]/, $1);
      return 0 if (grep(/^foreign$/, @kde_options)); # don't touch me
    }

    # Look for the tags that mean we should process this file.
    $metasourceTags = 0;
    $metasourceTags++    while ($MakefileData =~ /\n[^=#]*METASOURCES\s*=/g);

    my $pofileTag = 0;
    $pofileTag++    while ($MakefileData =~ /\nPOFILES\s*=/g);
    if ($pofileTag > 1)
    {
        print STDERR "Error: Only one POFILES tag allowed\n";
        $errorflag = 1;
    }

    while ($MakefileData =~ /\n\.SUFFIXES:([^\n]+)\n/g) {
	my @list=split(' ', $1);
	my $extions = " " . $cppExt . " ";
	foreach $ext (@list) {
	    if ($extions =~ / \*\Q$ext\E /) {
		$cxxsuffix = $ext;
		$cxxsuffix =~ s/\.//g;
		print STDOUT "will use suffix $cxxsuffix\n" if ($verbose);
		last;
	    }
	}
      }
						
    while ($MakefileData =~ /\n(\S*)_OBJECTS\s*=\s*([^\n]*)\n/g) {

      my $program = $1;
      my $objs = $2; # safe them

      my $ocv = 0;

      my @objlist = split(/[\s\034]+/, $objs);
      foreach $obj (@objlist) {
	if ($obj =~ /\$\((\S+)\)/ ) {
	  my $variable = $1;
	  if ($variable !~ 'OBJEXT') {
	    $ocv = 1;
	  }
	}
      }

      next if ($ocv);

      $program =~ s/^am_// if ($program =~ /^am_/);

      print STDOUT "found program $program\n" if ($verbose);
      push(@programs, $program);

      $realObjs{$program} = $objs;

      if ($MakefileData =~ /\n$program\_SOURCES\s*=\s*(.*)\n/) {
	$sources{$program} = $1;
      } else {
	$sources{$program} = "";
	print STDERR "found program with no _SOURCES: $program\n";
      }

      my $realprogram = $program;
      $realprogram =~ s/_/./g; # unmask to regexp
      if ($MakefileData =~ /\n($realprogram)(\$\(EXEEXT\)?)?:.*\$\($program\_OBJECTS\)/) {
	$realname{$program} = $1;
      } else {
      	# not standard Makefile - nothing to worry about
	$realname{$program} = "";
      }
    }
						
    my $lookup = '\nDEPDIR\s*=.*';
    if ($MakefileData !~ /($lookup)\n/) {
      $lookup = '\nbindir\s*=.*';
      if ($MakefileData =~ /($lookup)\n/) {
	substituteLine ($lookup, "DEPDIR = .deps\n$1");
      }
    } else {
      print STDERR "$printname defines DEPDIR. This means you're using automake > 1.4 - this is not supported!\n";
    }

    my $localTag = 0;
    $localTag++ if ($MakefileData =~ /\ninstall-\S+-local:/);

    return (!$errorflag);
}

#-----------------------------------------------------------------------------

# Gets the list of user defined directories - relative to $srcdir - where
# header files could be located.
sub tag_META_INCLUDES ()
{
    my $lookup = '[^=\n]*META_INCLUDES\s*=\s*(.*)';
    return 1    if ($MakefileData !~ /($lookup)\n/);
    print STDOUT "META_INCLUDE processing <$1>\n"       if ($verbose);

    my $headerStr = $2;
    removeLine ($lookup, $1);

    $headerStr =~ tr/\034/ /;
    my @headerlist = split(' ', $headerStr);

    foreach $dir (@headerlist)
    {
        $dir =~ s#\$\(srcdir\)#.#;
        if (! -d $dir)
        {
            print STDERR "Warning: $dir can't be found. ",
                            "Must be a relative path to \$(srcdir)\n";
        }
        else
        {
            push (@headerdirs, $dir);
        }
    }

    return 0;
}

#-----------------------------------------------------------------------------

sub tag_FINAL()
{
  my @final_names = ();

  foreach $program (@programs) {

    if ($sources{$program} =~ /\(/) {
      print STDERR "found ( in $program\_SOURCES. skipping\n" if ($verbose);
      next;
    }

    my $mocsources = "";

    my @progsources = split(/[\s\034]+/, $sources{$program});
    my %sourcelist = ();

    foreach $source (@progsources) {
      my $suffix = $source;
      $suffix =~ s/^.*\.([^\.]+)$/$1/;

      if (defined($sourcelist{$suffix})) {
	$sourcelist{$suffix} .= " " . $source;
      } else {
	$sourcelist{$suffix} .= $source;
      }
    }

    foreach $suffix (keys %sourcelist) {

      # See if this file contains c++ code. (ie Just check the files suffix against
      my $suffix_is_cxx = 0;
      foreach $cxx_suffix (split(' ', $cppExt)) {
       $cxx_suffix =~ s/^\*\.//;
       $cxx_suffix = quotemeta($cxx_suffix);
       if ($suffix =~ $cxx_suffix) {
         $suffix_is_cxx = 1;
         last; # $cxx_suffix
       }
      }

      my $mocfiles_in = ($suffix eq $cxxsuffix) &&
	defined($depedmocs{$program});

      my @sourcelist = split(/[\s\034]+/, $sourcelist{$suffix});

      if ((@sourcelist == 1 && !$mocfiles_in) || $suffix_is_cxx != 1 ) {

	# we support IDL on our own
	if ($suffix =~ /^skel$/ || $suffix =~ /^stub/ || $suffix =~ /^h$/) {
	  next;
	}
	
	foreach $file (@sourcelist) {

	  $file =~ s/\Q$suffix\E$//;
	
	  $finalObjs{$program} .= $file;
	  if ($program =~ /_la$/) {
	    $finalObjs{$program} .= "lo ";
	  } else {
	    $finalObjs{$program} .= "o ";
	  }
	}
	next; # suffix
      }

      my $source_deps = "";
      foreach $source (@sourcelist) {
	if (-f $source) {
	  $source_deps .= "\$(srcdir)/$source ";
	} else {
	  $source_deps .= "$source ";
	}
      }

      $handling = "$program.all_$suffix.$suffix: \$(srcdir)/Makefile.in " . $source_deps . " ";

      if ($mocfiles_in) {
	$handling .= $depedmocs{$program};
	foreach $mocfile (split(' ', $depedmocs{$program})) {
	  if ($mocfile =~ m/\.$suffix$/) {
	    $mocsources .= " " . $mocfile;
	  }
	}
      }

      $handling .= "\n";
      $handling .= "\t\@echo 'creating $program.all_$suffix.$suffix ...'; \\\n";
      $handling .= "\trm -f $program.all_$suffix.files $program.all_$suffix.final; \\\n";
      $handling .= "\techo \"#define KDE_USE_FINAL 1\" >> $program.all_$suffix.final; \\\n";
      $handling .= "\tfor file in " . $sourcelist{$suffix} . " $mocsources; do \\\n";
      $handling .= "\t  echo \"#include \\\"\$\$file\\\"\" >> $program.all_$suffix.files; \\\n";
      $handling .= "\t  test ! -f \$\(srcdir\)/\$\$file || egrep '^#pragma +implementation' \$\(srcdir\)/\$\$file >> $program.all_$suffix.final; \\\n";
      $handling .= "\tdone; \\\n";
      $handling .= "\tcat $program.all_$suffix.final $program.all_$suffix.files  > $program.all_$suffix.$suffix; \\\n";
      $handling .= "\trm -f $program.all_$suffix.final $program.all_$suffix.files\n";

      appendLines($handling);
	
      push(@final_names, "$program.all_$suffix.$suffix");
      $finalObjs{$program} .= "$program.all_$suffix.";
      if ($program =~ /_la$/) {
	$finalObjs{$program} .= "lo ";
      } else {
	$finalObjs{$program} .= "o ";
      }
    }
  }

  if ($use_final && @final_names >= 1) {
    # add clean-final target
    my $lines = "$cleantarget-final:\n";
    $lines .= "\t-rm -f " . join(' ', @final_names) . "\n" if (@final_names);
    appendLines($lines);
    $target_adds{"$cleantarget-am"} .= "$cleantarget-final ";

    foreach $finalfile (@final_names) {
      $finalfile =~ s/\.[^.]*$/.P/;
      $dep_finals .= " \$(DEPDIR)/$finalfile";
    }
  }
}

# Organises the list of headers that we'll use to produce moc files
# from.
sub tag_METASOURCES ()
{
    local @newObs           = ();  # here we add to create object files
    local @deped            = ();  # here we add to create moc files
    local $mocExt           = ".moc";
    local %mocFiles         = ();

    my $line = "";
    my $postEqual = "";

    my $lookup;
    my $found = "";

    if ($metasourceTags > 1) {
	$lookup = $program . '_METASOURCES\s*=\s*(.*)';
	return 1    if ($MakefileData !~ /\n($lookup)\n/);
	$found = $1;
    } else {
	$lookup = $program . '_METASOURCES\s*=\s*(.*)';
	if ($MakefileData !~ /\n($lookup)\n/) {
	    $lookup = 'METASOURCES\s*=\s*(.*)';
	    return 1    if ($MakefileData !~ /\n($lookup)\n/);
	    $found = $1;
	    $metasourceTags = 0; # we can use the general target only once
	} else {
	  $found = $1;
      }
    }
    print STDOUT "METASOURCE processing <$found>)\n"      if ($verbose);

    $postEqual = $found;
    $postEqual =~ s/[^=]*=//;

    removeLine ($lookup, $found);

    # Always find the header files that could be used to "moc"
    return 1    if (findMocCandidates ());

    if ($postEqual =~ /AUTO\s*(\S*)|USE_AUTOMOC\s*(\S*)/)
    {
	print STDERR "$printname: the argument for AUTO|USE_AUTOMOC is obsolete" if ($+);
	$mocExt = ".moc.$cxxsuffix";
	$haveAutomocTag = 1;
    }
    else
    {
        # Not automoc so read the list of files supplied which
        # should be .moc files.

        $postEqual =~ tr/\034/ /;

        # prune out extra headers - This also checks to make sure that
        # the list is valid.
        pruneMocCandidates ($postEqual);
    }

    checkMocCandidates ();

    if (@newObs) {
      my $ext =  ($program =~ /_la$/) ? ".moc.lo " : ".moc.o ";
      $realObjs{$program} .= "\034" . join ($ext, @newObs) . $ext;
      $depedmocs{$program} = join (".moc.$cxxsuffix " , @newObs) . ".moc.$cxxsuffix";
      foreach $file (@newObs) {
	$dep_files .= " \$(DEPDIR)/$file.moc.P";
      }
    }
    if (@deped) {
      $depedmocs{$program} .= " ";
      $depedmocs{$program} .= join('.moc ', @deped) . ".moc";
      $depedmocs{$program} .= " ";
    }
    addMocRules ();
}

#-----------------------------------------------------------------------------

# Returns 0 if the line was processed - 1 otherwise.
# Errors are logged in the global $errorflags
sub tag_AUTOMAKE ()
{
    my $lookup = '.*cd \$\(top_srcdir\)\s+&&\s+\$\(AUTOMAKE\)(.*)';
    return 1    if ($MakefileData !~ /($lookup)/);
    print STDOUT "AUTOMAKE processing <$1>\n"        if ($verbose);

    my $newLine = $1."\n\tcd \$(top_srcdir) && perl $thisProg $printname";
    substituteLine ($lookup, $newLine);
    $automkCall = $1;
    return 0;
}

#-----------------------------------------------------------------------------

sub tag_TOPLEVEL()
{
  my $lookup = 'TOPLEVEL_LANG\s*=\s*(\S+)';
  return 1 if ($MakefileData !~ /\n$lookup\n/);
  my $lang = $1;

  if (tag_SUBDIRS()) {
    print STDERR "Error: TOPLEVEL_LANG without SUBDIRS = \$(AUTODIRS) in $printname\n";
    $errorflag = 1;
    return 1;
  }

  my $pofiles = "";
  my @restfiles = ();
  opendir (THISDIR, ".");
  foreach $entry (readdir(THISDIR)) {
    next if (-d $entry);

    next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^#.*#$/ || $entry =~ /.gmo$/);

    if ($entry =~ /\.po$/) {
      $pofiles .= "$entry ";
      next;
    }
    push(@restfiles, $entry);
  }
  closedir (THISDIR);

  print STDOUT "pofiles found = $pofiles\n"   if ($verbose);
  handle_POFILES($pofiles, '$(TOPLEVEL_LANG)') if ($pofiles);

  if (@restfiles) {
    $target_adds{"install-data-am"} .= "install-nls-files ";
    $lines = "install-nls-files:\n";
    $lines .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_locale)/$lang\n";
    for $file (@restfiles) {
      $lines .= "\t\$(INSTALL_DATA) \$\(srcdir\)/$file \$(DESTDIR)\$(kde_locale)/$lang/$file\n";
    }
    appendLines($lines);
  }

  return 0;
}

#-----------------------------------------------------------------------------

sub tag_SUBDIRS ()
{
  if ($MakefileData !~ /\nSUBDIRS\s*=\s*\$\(AUTODIRS\)\s*\n/) {
    return 1;
  }

  my $subdirs;

  opendir (THISDIR, ".");
  foreach $entry (readdir(THISDIR)) {
    next if ($entry eq "CVS" || $entry =~ /^\./);
    if (-d $entry && -f $entry . "/Makefile.am") {
      $subdirs .= " $entry";
      next;
    }
  }
  closedir (THISDIR);

  my $lines = "SUBDIRS =$subdirs\n";
  substituteLine('SUBDIRS\s*=.*', $lines);
  return 0;
}

sub tag_IDLFILES ()
{
  my @psources = split(/[\034\s]+/, $sources{$program});
  my $dep_lines = "";
  my @cppFiles = ();

  foreach $source (@psources) {

    my $skel = ($source =~ m/\.skel$/);

    if ($source =~ m/\.stub$/ || $skel) {

      print STDERR "adding IDL file $source\n" if ($verbose);

      $source =~ s/\.(stub|skel)$//;

      my $sourcename;

      if ($skel) {
	$sourcename = "$source\_skel";
      } else {
	$sourcename = "$source\_stub";
      }

      my $sourcedir = '';
      if (-f "$makefileDir/$source.h") {
	$sourcedir = '$(srcdir)/';
      } else {
	if ($MakefileData =~ /\n$source\_DIR\s*=\s*(\S+)\n/) {#
	  $sourcedir = $1;
	  $sourcedir .= "/" if ($sourcedir !~ /\/$/);
	}
      }

      if ($allidls !~ /$source\_kidl/) {

	$dep_lines .= "$source.kidl: $sourcedir$source.h \$(DCOPIDL_DEPENDENCIES)\n";
	$dep_lines .= "\t\$(DCOPIDL) $sourcedir$source.h > $source.kidl || rm -f $source.kidl\n";

	$allidls .= $source . "_kidl ";
      }

      if ($allidls !~ /$sourcename/) {

	
	if ($skel) {
	  $dep_lines .= "$sourcename.$cxxsuffix: $source.kidl\n";
	  $dep_lines .= "\t\$(DCOPIDL2CPP) --c++-suffix $cxxsuffix --no-stub $source.kidl\n";
	} else {
	  $dep_lines .= "$sourcename.$cxxsuffix: $sourcename.h\n";
	  $dep_lines .= "$sourcename.h: $source.kidl\n";
	  $dep_lines .= "\t\$(DCOPIDL2CPP) --c++-suffix $cxxsuffix --no-skel $source.kidl\n";
	}
	@cppFiles =
	  `grep -l "^#include *.$sourcename\.h." $cppExt 2> /dev/null`;
        foreach $file (@cppFiles) {
	  chomp ($file);
	  $dep_lines .= "\$(srcdir)/$file: $sourcename.h\n";
	}
	
	# just to make sure the warning gets issused
	@cppFiles =
	  `grep -l "^#include *.$sourcename\.h." $hExt 2> /dev/null`;
	
	foreach $file (@cppFiles) {
	  print STDERR "Warning: $sourcename.h included in $printname/$file\n";
	}

	$allidls .= $sourcename . " ";
      }

      $idlfiles{$program} .= $sourcename . " ";

      if ($program =~ /_la$/) {
	$realObjs{$program} .= " $sourcename.lo";
      } else {
	$realObjs{$program} .= " $sourcename.\$(OBJEXT)";
      }
      $sources{$program} .= " $sourcename.$cxxsuffix";
      $idl_output .= "\\\n\t$sourcename.$cxxsuffix $sourcename.h $source.kidl ";
    }
  }
  if ($dep_lines) {
    appendLines($dep_lines);
  }

  if (0) {
    my $lookup = "($program)";
    $lookup .= '(|\$\(EXEEXT\))';
    $lookup =~ s/\_/./g;
    $lookup .= ":(.*..$program\_OBJECTS..*)";
#    $lookup = quotemeta($lookup);
    if ($MakefileData =~ /\n$lookup\n/) {

      my $line = "$1$2: ";
      foreach $file (split(' ', $idlfiles{$program})) {
        $line .= "$file.$cxxsuffix ";
      }
      $line .= $3;
      substituteLine($lookup, $line);
    } else {
      print STDERR "no built dependency found $lookup\n";
    }
  }

}

sub tag_ICON()
{
  my $lookup = 'KDE_ICON\s*=\s*([^\n]*)';
  return 1    if ($MakefileData !~ /\n$lookup/);
  my @_appnames = split(" ", $1);
  print STDOUT "KDE_ICON processing <@_appnames>\n"   if ($verbose);
  my @appnames = ();
  foreach $appname (@_appnames) {
    push(@appnames, quotemeta($appname));
  }

  my @files = ();
  opendir (THISDIR, ".");
  foreach $entry (readdir(THISDIR)) {
    next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^\#.*\#$/);
    next if (! -f $entry);
    foreach $appname (@appnames) {
      push(@files, $entry)
	if ($entry =~ /-$appname\.xpm/ || $entry =~ /-$appname\.png/);
    }
  }
  closedir (THISDIR);
  $target_adds{"install-data-am"} .= "install-kde-icons ";
  $target_adds{"uninstall-am"} .= "uninstall-kde-icons ";

  $install = "install-kde-icons:\n";
  $uninstall = "uninstall-kde-icons:\n";

  my %directories = ();

  foreach $file (@files)
    {
      my $newfile = $file;
      my $prefix = $file;
      $prefix =~ s/\.(png|xpm)$//;
      my $appname = $prefix;
      $appname =~ s/^[^-]+-// if ($appname =~ /-/) ;
      $appname =~ s/^[^-]+-// if ($appname =~ /-/) ;
      $appname = quotemeta($appname);
      $prefix =~ s/$appname$//;
      $prefix =~ s/-$//;

      $prefix = 'los-app' if ($prefix eq 'mini');
      $prefix = 'lom-app' if ($prefix eq 'lo');
      $prefix = 'hil-app' if ($prefix eq 'large');
      $prefix .= '-app' if ($prefix =~ m/^...$/);

      my $type = $prefix;
      $type =~ s/^.*-([^-]+)$/$1/;
      $prefix =~ s/^(.*)-[^-]+$/$1/;

      my %type_hash =
	(
	 'app' => 'apps',
	 'device' => 'devices',
	 'filesys' => 'filesystems',
	 'listitems' => 'listitems',
	 'mime' => 'mimetypes',
	 'toolbar' => 'toolbars'
	);

      if (! defined $type_hash{$type} ) {
	print STDERR "unknown icon type $type in $printname ($file)\n";
	next;
      }

      my %dir_hash =
	(
	 'los' => 'small/locolor',
	 'him' => 'medium/hicolor',
	 'lom' => 'medium/locolor',
	 'hil' => 'large/hicolor',
	);

      $newfile =~ s@.*-($appname\.(png|xpm?))@$1@;

      if (! defined $dir_hash{$prefix}) {
	print STDERR "unknown icon prefix $prefix in $printname\n";
	next;
      }

      my $dir = $dir_hash{$prefix} . "/" . $type_hash{$type};

      if (!defined $directories{$dir}) {
	$install .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_icondir)/$dir\n";
	$directories{$dir} = 1;
      }
	
      $install .= "\t\$(INSTALL_DATA) \$(srcdir)/$file \$(DESTDIR)\$(kde_icondir)/$dir/$newfile\n";
      $uninstall .= "\t-rm -f \$(DESTDIR)\$(kde_icondir)/$dir/$newfile\n";

    }

  appendLines($install . "\n" . $uninstall);

}

sub handle_POFILES($$)
{
  my @pofiles = split(" ", $_[0]);
  my $lang = $_[1];

  # Build rules for creating the gmo files
  my $tmp = "";
  my $allgmofiles     = "";
  my $pofileLine   = "POFILES =";
  foreach $pofile (@pofiles)
    {
        $pofile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
        $tmp .= "$1.gmo: $pofile\n";
        $tmp .= "\trm -f $1.gmo; \$(GMSGFMT) -o $1.gmo \$(srcdir)/$pofile\n";
        $allgmofiles .= " $1.gmo";
        $pofileLine  .= " $1.po";
    }
  appendLines ($tmp);
  my $lookup = 'POFILES\s*=([^\n]*)';
  if ($MakefileData !~ /\n$lookup/) {
    appendLines("$pofileLine\nGMOFILES =$allgmofiles");
  } else {
    substituteLine ($lookup, "$pofileLine\nGMOFILES =$allgmofiles");
  }

    if ($allgmofiles) {

        # Add the "clean" rule so that the maintainer-clean does something
        appendLines ("clean-nls:\n\t-rm -f $allgmofiles\n");

	$target_adds{"maintainer-clean"} .= "clean-nls ";

	$lookup = 'DISTFILES\s*=\s*(.*)';
	if ($MakefileData =~ /\n$lookup\n/) {
	  $tmp = "DISTFILES = \$(GMOFILES) \$(POFILES) $1";
	  substituteLine ($lookup, $tmp);
	}
    }

  $target_adds{"install-data-am"} .= "install-nls ";

  $tmp = "install-nls:\n";
  $tmp .= "install-nls:\n";
  if ($lang) {
    $tmp  .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES\n";
  }
  $tmp .= "\t\@for base in ";
  foreach $pofile (@pofiles)
    {
      $pofile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
      $tmp .= "$1 ";
    }

  $tmp .= "; do \\\n";
  if ($lang) {
    $tmp .= "\t  echo \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES/\$\$base.mo ;\\\n";
    $tmp .= "\t  test ! -f \$\$base.gmo || \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES/\$\$base.mo ;\\\n"
  } else {
    $tmp .= "\t  echo \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/\$\$base/LC_MESSAGES/\$(PACKAGE).mo ;\\\n";
    $tmp .= "\t  \$(mkinstalldirs) \$(DESTDIR)\$(kde_locale)/\$\$base/LC_MESSAGES ; \\\n";
    $tmp .= "\t  test ! -f \$\$base.gmo || \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/\$\$base/LC_MESSAGES/\$(PACKAGE).mo ;\\\n";
  }
  $tmp .= "\tdone\n\n";
  appendLines ($tmp);

  $target_adds{"uninstall"} .= "uninstall-nls ";

  $tmp = "uninstall-nls:\n";
  foreach $pofile (@pofiles)
    {
      $pofile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
      if ($lang) {
	$tmp .= "\trm -f \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES/$1.mo\n";
      } else {
	$tmp .= "\trm -f \$(DESTDIR)\$(kde_locale)/$1/LC_MESSAGES/\$(PACKAGE).mo\n";
      }
    }
  appendLines($tmp);

  $target_adds{"all"} .= "all-nls-\@USE_NLS\@ ";

  $tmp = "all-nls-no:\n";
  $tmp .= "all-nls-yes: \$(GMOFILES)\n";

  appendLines($tmp);

  $target_adds{"distdir"} .= "distdir-nls ";

  $tmp = "distdir-nls:\$(GMOFILES)\n";
  $tmp .= "\tfor file in \$(POFILES); do \\\n";
  $tmp .= "\t  cp \$(srcdir)/\$\$file \$(distdir); \\\n";
  $tmp .= "\tdone\n";
  $tmp .= "\ttest -z \"\$(GMOFILES)\" || cp \$(GMOFILES) \$(distdir)\n";

  appendLines ($tmp);

}

#-----------------------------------------------------------------------------

# Returns 0 if the line was processed - 1 otherwise.
# Errors are logged in the global $errorflags
sub tag_POFILES ()
{
    my $lookup = 'POFILES\s*=([^\n]*)';
    return 1    if ($MakefileData !~ /\n$lookup/);
    print STDOUT "POFILES processing <$1>\n"   if ($verbose);

    my $tmp = $1;

    # make sure these are all gone.
    if ($MakefileData =~ /\n\.po\.gmo:\n/)
    {
        print STDERR "Warning: Found old .po.gmo rules in $printname. New po rules not added\n";
        return 1;
    }

    # Either find the pofiles in the directory (AUTO) or use
    # only the specified po files.
    my $pofiles = "";
    if ($tmp =~ /^\s*AUTO\s*$/)
    {
        opendir (THISDIR, ".");
	next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^#.*#$/);
	$pofiles =  join(" ", grep(/\.po$/, readdir(THISDIR)));
        closedir (THISDIR);
        print STDOUT "pofiles found = $pofiles\n"   if ($verbose);
    }
    else
    {
        $tmp =~ s/\034/ /g;
        $pofiles = $tmp;
    }
    return 1    if (!$pofiles);        # Nothing to do

    handle_POFILES($pofiles, $kdelang);

    return 0;
}

sub helper_LOCALINSTALL($)
{
  my $lookup = "\n" . $_[0] . ":";
  if ($MakefileData =~ /($lookup)/) {

    my $install = $MakefileData;
    $install =~ s/\n/\035/g;
    $install =~ s/.*\035$_[0]:[^\035]*\035//;
    my $emptyline = 0;
    while (! $emptyline) {
      if ($install =~ /([^\035]*)\035(.*)/) {
	local $line = $1;
	$install = $2;
	if ($line =~ /^\s*$/ || $line !~ /^\t/) {
	  $emptyline = 1;
	} else {
	  replaceDestDir($line);
	}
      } else {
	$emptyline = 1;
      }
    }
  }

}

sub tag_LOCALINSTALL ()
{
  helper_LOCALINSTALL('install-exec-local');
  helper_LOCALINSTALL('install-data-local');
  helper_LOCALINSTALL('uninstall-local');

  return 0;
}

sub replaceDestDir($) {
  local $line = $_[0];

  if ($line =~ /^\s*\$\(mkinstalldirs\)/ || $line =~ /^\s*\$\(INSTALL\S*\)/
      || $line =~ /^\s*(-?rm.*) \S*$/)
  {
    $line =~ s/^(.*) ([^\s]*)\s*$/$1 \$(DESTDIR)$2/ if ($line !~ /\$\(DESTDIR\)/);
  }

  if ($line ne $_[0]) {
    $_[0] = quotemeta $_[0];
    substituteLine($_[0], $line);
  }
}

#---------------------------------------------------------------------------
sub tag_CLOSURE () {
  return if ($program !~ /_la$/);

  my $lookup = quotemeta($realname{$program}) . ":.*?\n\t.*?\\((.*?)\\) .*\n";
  $MakefileData =~ m/$lookup/;
  return if ($1 !~ /CXXLINK/);

  if ($MakefileData !~ /\n$program\_LDFLAGS\s*=.*-no-undefined/) {
    print STDERR "Report: $program contains undefined in $printname\n" if ($program =~ /^lib/ || $dryrun);
    return;
  }
  my $closure = $realname{$program} . ".closure";
  my $lines = "$closure: \$($program\_OBJECTS) \$($program\_DEPENDENCIES)\n";
  $lines .= "\t\@echo \"int main() {}\" > $program\_closure.$cxxsuffix\n";
  $lines .= "\t\@\$\(LTCXXCOMPILE\) -c $program\_closure.$cxxsuffix\n";
  $lines .= "\t\@\$\(CXXLINK\) $program\_closure.lo \$($program\_LDFLAGS) \$($program\_OBJECTS) \$($program\_LIBADD) \$(LIBS)\n";
  $lines .= "\t\@rm -f $program\_closure.* $closure\n";
  $lines .= "\t\@echo \"timestamp\" > $closure\n";
  $lines .= "\n";
  appendLines($lines);
  $lookup = $realname{$program} . ": (.*)";
  if ($MakefileData =~ /\n$lookup\n/) {
    $lines  = "\@KDE_USE_CLOSURE_TRUE@". $realname{$program} . ": $closure $1";
    $lines .= "\n\@KDE_USE_CLOSURE_FALSE@" . $realname{$program} . ": $1";
    substituteLine($lookup, $lines);
  }
}

#-----------------------------------------------------------------------------
# Returns 0 if the line was processed - 1 otherwise.
# Errors are logged in the global $errorflags
sub tag_DOCFILES ()
{
    if ($MakefileData =~ /\nSUBDIRS\s*=/) { # subdirs
      $MakefileData =~ /\n(.*-recursive:\s*)\n/;
      my $orig_rules = $1;
      my $rules = $orig_rules;
      $rules =~ s/:\s*$//;
      substituteLine($orig_rules, "$rules docs-recursive:");
      appendLines("docs: docs-recursive docs-am\n");
    } else {
      appendLines("docs: docs-am\n");
    }

    my $lookup = 'KDE_DOCS\s*=\s*([^\n]*)';
    goto nodocs    if ($MakefileData !~ /\n$lookup/);
    print STDOUT "KDE_DOCS processing <$1>\n"   if ($verbose);

    tag_SUBDIRS();

    my $tmp = $1;

    # Either find the files in the directory (AUTO) or use
    # only the specified po files.
    my $files = "";
    my $appname = $tmp;
    $appname =~ s/^(\S*)\s*.*$/$1/;
    if ($appname =~ /AUTO/) {
      $appname = basename($makefileDir);
    }

    if ($tmp !~ / - /)
    {
        opendir (THISDIR, ".");
	foreach $entry (readdir(THISDIR)) {
	  next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^\#.*\#$/);
	  next if (! -f $entry);
	  $files .= "$entry ";
	}
        closedir (THISDIR);
        print STDOUT "docfiles found = $files\n"   if ($verbose);
    }
    else
    {
        $tmp =~ s/\034/ /g;
	$tmp =~ s/^\S*\s*-\s*//;
        $files = $tmp;
    }
    goto nodocs if (!$files);        # Nothing to do

    if ($files =~ /(^| )index\.docbook($| )/) {

      my $lines = "";
      $lines .= "docs-am: HTML HTML/index.html\n";
      $lines .= "\n";
      $lines .= "HTML:\n";
      $lines .= "\ttest -d HTML || mkdir HTML\n";
      $lines .= "\n";
      $lines .= "HTML/index.html: index.docbook\n";
      $lines .= "\t\@test -d HTML && rm -r HTML\n";
      $lines .= "\tkdb2html \$(srcdir)/index.docbook\n";
      $lines .= "\n";
      $lines .= "install-docs:\n";
      $lines .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname\n";
      $lines .= "\t\@if test -d HTML; then \\\n";
      $lines .= "\t(cd HTML && for file in * .anchors; do if test -f \$\$file; then \\\n";
      $lines .= "\techo \$(INSTALL_DATA) \$\$file \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$file ;\\\n";
      $lines .= "\t\$(INSTALL_DATA) \$\$file \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$file; \\\n";
      $lines .= "\tfi; done); fi\n";
      $lines .= "\t-rm -f \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/common\n";
      $lines .= "\t\$(LN_S) ../../$kdelang/common \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/common\n";
      $lines .= "\n";
      $lines .= "uninstall-docs:\n";
      $lines .= "\t-rm -rf \$(kde_htmldir)/$kdelang/$appname\n";
      $lines .= "\n";
      $target_adds{"install-data-am"} .= "install-docs ";
      $target_adds{"uninstall"} .= "uninstall-docs ";
      appendLines ($lines);
      $docsadded = 1;
    } else {
      appendLines("docs-am:\n");
    }

    $target_adds{"install-data-am"} .= "install-nls";
    $target_adds{"uninstall"} .= "uninstall-nls ";

    $tmp = "install-nls:\n";
    $tmp .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname\n";
    $tmp .= "\t\@for base in $files; do \\\n";
    $tmp .= "\t  echo \$(INSTALL_DATA) \$\$base \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$base ;\\\n";
    $tmp .= "\t  \$(INSTALL_DATA) \$(srcdir)/\$\$base \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$base ;\\\n";
    $tmp .= "\tdone\n";
    $tmp .= "\n";
    $tmp .= "uninstall-nls:\n";
    $tmp .= "\tfor base in $files; do \\\n";
    $tmp .= "\t  rm -f \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$base ;\\\n";
    $tmp .= "\tdone\n\n";
    appendLines ($tmp);

    $target_adds{"distdir"} .= "distdir-nls ";

    $tmp = "distdir-nls:\n";
    $tmp .= "\tfor file in $files; do \\\n";
    $tmp .= "\t  cp \$(srcdir)/\$\$file \$(distdir); \\\n";
    $tmp .= "\tdone\n";

    appendLines ($tmp);

    return 0;

  nodocs:
    appendLines("docs-am:\n");
    return 1;
}

#-----------------------------------------------------------------------------
# Find headers in any of the source directories specified previously, that
# are candidates for "moc-ing".
sub findMocCandidates ()
{
    my @list = ();
    foreach $dir (@headerdirs)
    {
        chdir ($dir);
        @list = `grep -l '^.*Q_OBJECT' $hExt 2> /dev/null`;
        chdir ($makefileDir);

        # The assoc array of root of headerfile and header filename
        foreach $hFile (@list)
        {
            chomp ($hFile);
            $hFile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
            if ($mocFiles{$1})
            {
                print STDERR "Warning: Multiple header files found for $1\n";
                next;                           # Use the first one
            }
            $mocFiles{$1} = "$dir\035$hFile";   # Add relative dir
        }
    }

    return 0;
}

#-----------------------------------------------------------------------------

# The programmer has specified a moc list. Prune out the moc candidates
# list that we found based on looking at the header files. This generates
# a warning if the programmer gets the list wrong, but this doesn't have
# to be fatal here.
sub pruneMocCandidates ($)
{
    my %prunedMoc = ();
    local @mocList = split(' ', $_[0]);

    foreach $mocname (@mocList)
    {
        $mocname =~ s/\.moc$//;
        if ($mocFiles{$mocname})
        {
            $prunedMoc{$mocname} = $mocFiles{$mocname};
        }
        else
        {
            my $print = $makefileDir;
            $print =~ s/^\Q$topdir\E\\//;
            # They specified a moc file but we can't find a header that
            # will generate this moc file. That's possible fatal!
            print STDERR "Warning: No moc-able header file for $print/$mocname\n";
        }
    }

    undef %mocFiles;
    %mocFiles = %prunedMoc;
}

#-----------------------------------------------------------------------------

# Finds the cpp files (If they exist).
# The cpp files get appended to the header file separated by \035
sub checkMocCandidates ()
{
    my @cppFiles = ();

    foreach $mocFile (keys (%mocFiles))
    {
        # Find corresponding c++ files that includes the moc file
        @cppFiles =
            `grep -l "^#include[ ]*.$mocFile\.moc." $cppExt 2> /dev/null`;

        if (@cppFiles == 1)
        {
            chomp $cppFiles[0];
            $mocFiles{$mocFile} .= "\035" . $cppFiles[0];
	    push(@deped, $mocFile);
            next;
        }

        if (@cppFiles == 0)
        {
            push (@newObs, $mocFile);           # Produce new object file
            next    if ($haveAutomocTag);       # This is expected...
            # But this is an error we can deal with - let them know
            print STDERR
                "Warning: No c++ file that includes $mocFile.moc\n";
            next;
        }
        else
        {
            # We can't decide which file to use, so it's fatal. Although as a
            # guess we could use the mocFile.cpp file if it's in the list???
            print STDERR
                "Error: Multiple c++ files that include $mocFile.moc\n";
            print STDERR "\t",join ("\t", @cppFiles),"\n";
            $errorflag = 1;
            delete $mocFiles{$mocFile};
            # Let's continue and see what happens - They have been told!
        }
    }
}

#-----------------------------------------------------------------------------

# Add the rules for generating moc source from header files
# For Automoc output *.moc.cpp but normally we'll output *.moc
# (We must compile *.moc.cpp separately. *.moc files are included
# in the appropriate *.cpp file by the programmer)
sub addMocRules ()
{
    my $cppFile;
    my $hFile;
    my $cleanMoc = "";

    foreach $mocFile (keys (%mocFiles))
    {
        undef $cppFile;
        ($dir, $hFile, $cppFile) =  split ("\035", $mocFiles{$mocFile}, 3);
        $dir =~ s#^\.#\$(srcdir)#;
        if (defined ($cppFile))
        {
            appendLines ("\$(srcdir)/$cppFile: $mocFile.moc\n$mocFile.moc: $dir/$hFile\n\t\$(MOC) $dir/$hFile -o $mocFile.moc\n");
            $cleanMoc .= " $mocFile.moc";
        }
        else
        {
            appendLines ("$mocFile$mocExt: $dir/$hFile\n\t\$(MOC) $dir/$hFile -o $mocFile$mocExt\n");
            $cleanMoc .= " $mocFile$mocExt";
        }
    }
	
    if ($cleanMoc) {
      # Always add dist clean tag
      # Add extra *.moc.cpp files created for USE_AUTOMOC because they
      # aren't included in the normal *.moc clean rules.
      appendLines ("$cleantarget-metasources:\n\t-rm -f $cleanMoc\n");
      $target_adds{"$cleantarget-am"} .= "$cleantarget-metasources ";
    }
  }

#-----------------------------------------------------------------------------

sub updateMakefile ()
{
    return if ($dryrun);

    open (FILEOUT, "> $makefile")
                        || die "Could not create $makefile: $!\n";

    print FILEOUT "\# $progId - " . '$Revision$ '  . "\n";
    $MakefileData =~ s/\034/\\\n/g;    # Restore continuation lines
    print FILEOUT $MakefileData;
    close FILEOUT;
}

#-----------------------------------------------------------------------------

# The given line needs to be removed from the makefile
# Do this by adding the special "removed line" comment at the line start.
sub removeLine ($$)
{
    my ($lookup, $old) = @_;

    $old =~ s/\034/\\\n#>- /g;          # Fix continuation lines
    $MakefileData =~ s/\n$lookup/\n#>\- $old/;
}

#-----------------------------------------------------------------------------

# Replaces the old line with the new line
# old line(s) are retained but tagged as removed. The new line(s) have the
# "added" tag placed before it.
sub substituteLine ($$)
{
    my ($lookup, $new) = @_;

    if ($MakefileData =~ /\n($lookup)/) {
      $old = $1;
      $old =~ s/\034/\\\n#>\- /g;         # Fix continuation lines
      $new =~ s/\034/\\\n/g;
      my $newCount = 1;
      $newCount++  while ($new =~ /\n/g);

      $MakefileData =~ s/\n$lookup/\n#>- $old\n#>\+ $newCount\n$new/;
    } else {
      print STDERR "Warning: substitution of \"$lookup\" in $printname failed\n";
    }
}

#-----------------------------------------------------------------------------

# Slap new lines on the back of the file.
sub appendLines ($)
{
    my ($new) = @_;

    $new =~ s/\034/\\\n/g;        # Fix continuation lines
    my $newCount = 1;
    $newCount++  while ($new =~ /\n/g);

    $MakefileData .= "\n#>\+ $newCount\n$new";
}

#-----------------------------------------------------------------------------

# Restore the Makefile.in to the state it was before we fiddled with it
sub restoreMakefile ()
{
    $MakefileData =~ s/# $progId[^\n\034]*[\n\034]*//g;
    # Restore removed lines
    $MakefileData =~ s/([\n\034])#>\- /$1/g;
    # Remove added lines
    while ($MakefileData =~ /[\n\034]#>\+ ([^\n\034]*)/)
    {
        my $newCount = $1;
        my $removeLines = "";
        while ($newCount--) {
            $removeLines .= "[^\n\034]*([\n\034]|)";
        }
        $MakefileData =~ s/[\n\034]#>\+.*[\n\034]$removeLines/\n/;
    }
}

#-----------------------------------------------------------------------------
